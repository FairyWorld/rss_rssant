<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Dozer的技术小站</title>
		<description>Dozer&#039;s Technology Blog</description>
		<link>/</link>
		<atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>Service Mesh 实践（八）：分布式上下文</title>
				<description>&lt;h3 id=&quot;什么是分布式上下文&quot;&gt;什么是分布式上下文&lt;/h3&gt;

&lt;p&gt;产品经理突然来了个需求，希望在一些事件打点的地方记录一下用户的各种信息：IP，User Agent，Accept Language 等。&lt;/p&gt;

&lt;p&gt;但数据打点是分散在各个地方的，而且需求变化非常快，我们怎么样才可以随时随地拿到这些信息呢？&lt;/p&gt;

&lt;p&gt;一种笨办法就是在所有函数调用的地方把相关信息一层层往下传，但你应该没见过这样的代码，实在是太麻烦了。&lt;/p&gt;

&lt;p&gt;另外一种方式就是直接从一个静态方法里拿到当前的 Request 对象，并从中拿到各种信息。例如 C# 中是这样的：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HttpContext.Current.Request&lt;/code&gt;，Python Flask 中是这样的：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;from flask import request&lt;/code&gt;。如果进去看看源码的话就会发现一般它们都是通过 Thread Local 来实现的。大部分的 HTTP Server 都是一个 Request 只由一个线程处理，所以这么做没什么问题。&lt;/p&gt;

&lt;p&gt;而 Golang 的并发模型不一样，所以 Golang 无法这么做，Golang 需要显示地传播 Context。同样，用 Netty 做 HTTP Server 的话，并发模型也是完全不一样的，同样无法直接使用 Thread Local，只能显示传播 Context。还有基于 RxJava 实现的也无法这么做。&lt;/p&gt;

&lt;p&gt;上下文本质上是一种隐式传播的信息，简化工作量。上面提到的这些都是程序内部的上下文，如果把这个隐式的信息传播扩展到微服务之间，那么它就变成分布式上下文了。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;rpc-框架中的分布式上下文&quot;&gt;RPC 框架中的分布式上下文&lt;/h3&gt;

&lt;p&gt;大部分 RPC 框架都会自动传播上下文，用户也可以手动添加一下信息，让它自动传播。&lt;/p&gt;

&lt;p&gt;例如 Dubbo 中就有这样的功能：&lt;a href=&quot;http://dubbo.apache.org/zh-cn/docs/user/demos/attachment.html&quot;&gt;隐式参数&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A 在调用 B 之前调用这个方法：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RpcContext.getContext().setAttachment(&quot;user-agent&quot;, userAgent);&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;接下来 B 在调用 C，C 在调用 D，每一个下游服务都可以得到这个信息。&lt;/p&gt;

&lt;p&gt;但是，我们主要使用的是 gRPC 和 HTTP，它们的协议中并没有设计这块，所以必须要手动处理了。&lt;/p&gt;

&lt;p&gt;这也是为什么基于 gRPC 或 HTTP 的微服务要做分布式追踪也只能手动处理，因为分布式追踪能串起来的关键就是要透传类似 Request ID 这样的标记，代表你们是一条链路上的。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;opentracing-中的-baggage&quot;&gt;OpenTracing 中的 Baggage&lt;/h3&gt;

&lt;p&gt;从底层原理上来看，分布式上下文和分布式追踪有一个共同点，它们都要透传一些信息，这部分代码完全是可以公用的。&lt;/p&gt;

&lt;p&gt;这也是为什么 OpenTracing 标准中规范了 Baggage 这个特性：&lt;a href=&quot;https://github.com/opentracing/specification/blob/master/specification.md#set-a-baggage-item&quot;&gt;https://github.com/opentracing/specification/blob/master/specification.md#set-a-baggage-item&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果你已经使用了任何符合 OpenTracing 标准的分布式追踪框架，你可以直接读取或者写入各种信息，它会自动帮你透传。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;tracer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;activeSpan&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setBaggageItem&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;user-agent&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userAgent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它的底层也非常简单，例如你远程调用的是 HTTP，那么它会在你调用任何 HTTP 请求的时候注入一个 HTTP Header：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Baggage-User-Agent: userAgent&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;下游服务收到请求后，自动提取所有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Baggage-&lt;/code&gt;开头的 HTTP Header 并放到内存中。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;倔强的-elastic-apm&quot;&gt;倔强的 Elastic APM&lt;/h3&gt;

&lt;p&gt;之前的文章提到过，我们把分布式追踪的框架改成了 Elastic APM：&lt;a href=&quot;/2020/02/replace-istio-mixer.html&quot;&gt;Service Mesh 实践（二）：Istio Mixer 模块的性能问题与替代方案&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Elastic APM 并不仅仅做了一个分布式追踪，所以它并没有遵循 OpenTracing 标准。&lt;/p&gt;

&lt;p&gt;Elastic APM 应该是 OpenTracing 一个超集，它其实实现了一个 OpenTracing Bridge，想要迁移到 Elastic APM 可以直接把底层的框架替换掉，然后基于 OpenTracing 标准写代码。这并不是 Elastic APM 推荐的长期实现方案，因为这样会缺少部分功能。&lt;/p&gt;

&lt;p&gt;除此以外，我们发现这么做以后，OpenTracing 中的 Baggage 功能竟然失效了，看了源码才知道，Elastic APM 直接留了个空函数。&lt;/p&gt;

&lt;p&gt;经过询问后，我们才得知它们不想基于 OpenTracing 的标准做这个，以后要实现的话，也会基于 W3C 的标准做。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://discuss.elastic.co/t/any-plan-for-support-opentracing-baggage/182672&quot;&gt;Any plan for support opentracing baggage?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://w3c.github.io/correlation-context/&quot;&gt;Propagation format for distributed trace context: Trace Context headers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;毕竟是半个竞争对手，不用对方的标准也可以理解。然而 W3C 的标准还在草案阶段，所以 Elastic APM 暂时并没有实现这个功能。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;自研&quot;&gt;自研&lt;/h3&gt;

&lt;p&gt;既然底层的原理都知道，也有两份开源作业摆在我们面前了，Elastic APM 暂时又不想实现，那么只能自己自研了。&lt;/p&gt;

&lt;p&gt;其实这块不难，主要就是如何在微服务之间传播，如何在程序内部传播，还有两者的衔接。相关技术细节都可以参考 Elastic APM 和 Jaeger，因为他们也做了类似的事情。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;微服务之间传播&quot;&gt;微服务之间传播&lt;/h4&gt;

&lt;p&gt;这块参考 OpenTracing 标准和 W3C 草案，他们本质上没有太大的区别，只是 HTTP Header 用的不同而已。&lt;/p&gt;

&lt;p&gt;因为我们已经有部分项目在用 OpenTracing 的 Baggage 功能了，所以为了少做改动，我们自研设计的协议也是同样的格式。&lt;/p&gt;

&lt;p&gt;最终格式类似这样：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Baggage-User-Agent: Mozilla/5.0&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Baggage-User-Id: d7af84f8-877c-414d-b008-e9d60a16ac61&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Baggage-User-Role: leader&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;内外衔接&quot;&gt;内外衔接&lt;/h4&gt;

&lt;p&gt;作为一个 HTTP Server，怎么拿到这些 Header 并且透传呢？&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HandleFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;userId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Header&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Baggage-User-Id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;GET&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;http://127.0.0.1:8888&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Header&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Baggage-User-Id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;resp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DefaultClient&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Do&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ListenAndServe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;:8080&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不借助任何中间件的话，直接手写就行了，把上游的 Header 读出来，然后传播到下游。这里的代码只是一个演示，实际还要根据前缀匹配把所有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Baggage-&lt;/code&gt;开头的都透传。&lt;/p&gt;

&lt;p&gt;这样的代码很明显不能让人接受。但幸运的是，大部分语言的大部分框架都可以很方便地实现自动透传。&lt;/p&gt;

&lt;p&gt;面向对象的语言自己实现一下对应的接口，然后包装一下即可。然后 Python 这样的动态语言直接替换对应的方法就行。&lt;/p&gt;

&lt;p&gt;用户用的时候，需要在程序中注册一下，例如 Golang 中 HTTP Server 和 HTTP Client 需要这样注册：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cphttp&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;github.com/AminoApps/context-propagation-go/module/context-propagation-http&quot;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ListenAndServe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;:8080&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cphttp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Wrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;client&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cphttp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WrapClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;程序内部传播&quot;&gt;程序内部传播&lt;/h4&gt;

&lt;p&gt;再看上面手写代码的例子：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HandleFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;userId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Header&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Baggage-User-Id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;GET&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;http://127.0.0.1:8888&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Header&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Baggage-User-Id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;resp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DefaultClient&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Do&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ListenAndServe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;:8080&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从上游拿到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;userId&lt;/code&gt;后，如果马上就要调用下游服务，那么不用特殊的处理。&lt;/p&gt;

&lt;p&gt;但是如果调用下游调用别的 HTTP 服务的代码很深，你需要一个个手动往下传播吗？这其实就是最上面提到的问题，不同的语言用不同的处理方式。&lt;/p&gt;

&lt;p&gt;Golang 的传播过程就是这样的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;HTTP Server 从 Header 中提取 Baggage&lt;/li&gt;
  &lt;li&gt;存入 Context，后续调用传播 Context&lt;/li&gt;
  &lt;li&gt;调用下游 HTTP 服务的时候从 Context 中提取出 Baggage&lt;/li&gt;
  &lt;li&gt;将 Baggage 写入 Header&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Java，Python 略有不同，主要区别就是不是通过 Context 传播了，直接放 Thread Local 就行了。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;开源项目&quot;&gt;开源项目&lt;/h4&gt;

&lt;p&gt;其中，Golang 和 Python 版本我们已经开源。&lt;/p&gt;

&lt;p&gt;Golang 版实现地最全面，支持了各种协议和框架：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/AminoApps/context-propagation-go&quot;&gt;Context Propagation Go&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Gin&lt;/li&gt;
  &lt;li&gt;Standard Http Server&lt;/li&gt;
  &lt;li&gt;Standard Http Client&lt;/li&gt;
  &lt;li&gt;gRPC Server&lt;/li&gt;
  &lt;li&gt;gRPC Client&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;Python 我们内部用的不多，对常用的做了一下支持：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/AminoApps/context-propagation-python&quot;&gt;Context Propagation Python&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;flask&lt;/li&gt;
  &lt;li&gt;requests&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;Java 为什么不支持？&lt;/p&gt;

&lt;p&gt;传统的 Java 代码支持起来不难，利用 Thread Local 就行了。但微服务中的 Java HTTP Server 如果使用传统的并发模型，会很吃力。&lt;/p&gt;

&lt;p&gt;Java 本身也在做相关转型，Spring Webflux，Vert.x 或者是别的基于 Netty 的框架，并发模型变了以后同一个请求就不一定在同一个线程上处理了。&lt;/p&gt;

&lt;p&gt;而它们各自都有一套类似 Context 的解决方案。&lt;/p&gt;

&lt;p&gt;所以 Java 想要做的话，需要支持的东西太多了，暂时并没有一个合适的标准。&lt;/p&gt;

&lt;p&gt;而且我们内部 Java 不多，以后也不推荐用 Java，所以这项工作就暂缓执行了。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;安全性&quot;&gt;安全性&lt;/h3&gt;

&lt;p&gt;我们之前把用户认证放到了 API Gateway 中，可以看看这篇文章：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/2020/02/api-gateway.html&quot;&gt;Service Mesh 实践（四）：从开源 Ingress 到自研 API Gateway&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;那么下游服务怎么知道这个调用链是哪个用户产生的呢？&lt;/p&gt;

&lt;p&gt;这里就需要用到分布式上下文了：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;API Gateway 对 Session 信息解码&lt;/li&gt;
  &lt;li&gt;API Gateway 将 解码后的 User Id 通过 Baggage 透传&lt;/li&gt;
  &lt;li&gt;下游业务通过 Baggage 得到 User Id&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有了上述中间件以后，只要调用链上的服务都整合了中间件，下游服务可以非常轻松地拿到 User Id 了。&lt;/p&gt;

&lt;p&gt;那这里就有两个问题了，如果用户熟悉我们内部系统的一些协议，直接通过外网传播 Baggage 进来怎么办？&lt;/p&gt;

&lt;p&gt;内部服务有人作恶，想办法伪造了 Baggage 怎么办？&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;防范公网请求&quot;&gt;防范公网请求&lt;/h4&gt;

&lt;p&gt;对外防范是非常重要的，不能有一点漏洞。否则会对内部系统造成很大的影响。例如一个用户通过伪造 Baggage，完全可以模拟成另外一个用户。&lt;/p&gt;

&lt;p&gt;然而这块的解决方案也非常简单。&lt;/p&gt;

&lt;p&gt;对于分布式上下文来说，这本身就是一个内部系统之间的协议，也就是说所有外部请求过来的流量都不应该带有相关协议。&lt;/p&gt;

&lt;p&gt;所以我们在 API Gateway 这一层直接抛弃所有的分布式上下文相关信息就行了。这样用户也就无法从公网伪造任何数据了。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;防范内网请求&quot;&gt;防范内网请求&lt;/h4&gt;

&lt;p&gt;对内而言，其实如果真要防范是防不慎防的，内部员工有一万种方式攻破你的系统。目前我们服务间调用都没有相关认证，所以这里伪造 Baggage 并不是一个太大的问题。&lt;/p&gt;

&lt;p&gt;虽然没有去做，但也要想清楚以后如何去做。&lt;/p&gt;

&lt;p&gt;如何验证这个 Baggage 真的是某个人生成的呢？&lt;/p&gt;

&lt;p&gt;银行如何知道转账请求真的是你提交的呢？&lt;/p&gt;

&lt;p&gt;还记得银行的 U 盾吗？&lt;/p&gt;

&lt;p&gt;其实这里也可以用类似的数字签名的机制，API Gateway 不仅返回 Baggage，还要对 Baggage 内容利用私钥进行签名。&lt;/p&gt;

&lt;p&gt;使用这个 Baggage 的服务为了认证这个 Baggage 是不是 API Gateway 生成的，那么就需要利用公钥去验证。&lt;/p&gt;

&lt;p&gt;大致思路是这样的，但实际却还有很多问题，例如 API Gateway 如何把公钥安全地给别的服务？API Gateway 如何安全地存放私钥？别的服务也要生成 Baggage 并进行签名怎么办？&lt;/p&gt;

&lt;p&gt;这里环环相扣，想要完美解决就需要很多东西，并不是一个很容易解决的问题。&lt;/p&gt;
</description>
				<pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate>
				<link>/2020/03/distributed-context.html</link>
				<guid isPermaLink="true">/2020/03/distributed-context.html</guid>
			</item>
		
			<item>
				<title>Service Mesh 实践（七）：CI / CD 的变迁</title>
				<description>&lt;h3 id=&quot;ci--cd-需要做成什么样&quot;&gt;CI / CD 需要做成什么样&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;CI：持续集成&lt;/li&gt;
  &lt;li&gt;CD：持续发布&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CI / CD 是我们整个 Service Mesh 转型过程中最艰难的一个环节。&lt;/p&gt;

&lt;p&gt;为什么最艰难？&lt;/p&gt;

&lt;p&gt;CI / CD 本质上要解决的问题是：标准 + 自动化脚本 + 可视化 + 通知。&lt;/p&gt;

&lt;p&gt;不同的公司情况不同，标准也会不同，因为在没有经验的情况下，很难制定出合理的标准。&lt;/p&gt;

&lt;p&gt;没有标准也就不能有足够抽象好用的自动化脚本，为一个项目写一些脚本不难，写出抽象好用的脚本很难。&lt;/p&gt;

&lt;p&gt;可视化和通知优先考虑开源产品，这两块在两年前也没什么可选的。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;第一版简单粗暴有效&quot;&gt;第一版简单粗暴有效&lt;/h3&gt;

&lt;p&gt;遇到这种情况比较好的解决办法就是先做一个 MVP，让大家用起来，在使用的过程中自然会冒出大量的改进意见。&lt;/p&gt;

&lt;p&gt;两年前，我们公司的状况是几乎没有任何现成的 CI / CD，而且开发们用的开发语言很多。&lt;/p&gt;

&lt;p&gt;当时也没有什么可选的技术方案。&lt;/p&gt;

&lt;p&gt;最后只看到了一个 Jenkins Pipeline + Kubernetes Plugin 可以满足我们的需求。&lt;/p&gt;

&lt;p&gt;它的基本用法就是基于 Groovy 语言，配合各种插件，把整个 CI / CD 的过程用脚本写出来。&lt;/p&gt;

&lt;p&gt;关键的这份脚本叫&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Jenkinsfile&lt;/code&gt;，大致是这样的：&lt;/p&gt;

&lt;div class=&quot;language-groovy highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;registry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;private-docker-repository-address&quot;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;default&quot;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;projectName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;user-service&quot;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imageName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;user-service:latest&quot;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;podTemplate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;containers:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;containerTemplate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;name:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'maven'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;image:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'maven'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;command:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'cat'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;ttyEnabled:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;containerTemplate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;name:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'docker'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;image:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'docker'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;command:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'cat'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;ttyEnabled:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;containerTemplate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;name:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'helm'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;image:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'alpine/helm'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;command:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'cat'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;ttyEnabled:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;],&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;volumes:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;hostPathVolume&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;mountPath:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'/var/run/docker.sock'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;hostPath:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'/var/run/docker.sock'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;POD_LABEL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;checkout&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scm&lt;/span&gt;

    &lt;span class=&quot;nf&quot;&gt;stage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Test &amp;amp; Build Jar'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'maven'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sh&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;mvn clean install&quot;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;stage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Build Docker'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'docker'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;docker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imageName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;docker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;withRegistry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;registry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;docker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imageName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;stage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Deploy'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'helm'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;sh&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&quot;helm upgrade ${projectName} ./charts/${projectName} -i --namespace ${namespace} \
                --set image=${registry}/${imageName} \
                --set resources.limits.cpu=2 \
                --set resources.limits.memory=1Gi \
                --set resources.requests.cpu=1 \
                --set resources.requests.memory=1Gi \
                --debug&quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它的大致运行过程是 Jenkins 会读取你这份&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Jenkinsfile&lt;/code&gt;文件，根据你声明的容器组装成一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt;，然后在 Kubernetes 集群里运行。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Jenkinsfile&lt;/code&gt;写好后，在 Jenkins 里创建一个 Pipeline 项目就行了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020/03/jenkins-create.png&quot; alt=&quot;Jenkins Create&quot; /&gt;&lt;/p&gt;

&lt;p&gt;大致的项目结构也很简单：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
├── Dockerfile
├── Jenkinsfile
├── charts
│   └── user-service/
└── src/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个方案的最大优点是什么？自由，灵活。&lt;/p&gt;

&lt;p&gt;开发可以自由定制自己的 CI / CD 过程，我们不需要任何标准，无论是什么语言，是新项目还是老项目，大家都可以定制化自己的脚本。&lt;/p&gt;

&lt;p&gt;有点像那个迪斯尼小路的故事，在地上种上草任由游客踩踏，最后出来的路就是最佳路径。嗯，有点心灵鸡汤的味道。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;第一版中遇到的问题&quot;&gt;第一版中遇到的问题&lt;/h3&gt;

&lt;p&gt;第一版简单粗暴，期间也遇到了不少小问题，这里可以说说解决方案。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;docker-in-docker&quot;&gt;Docker in Docker&lt;/h4&gt;

&lt;p&gt;我们的 Jenkins 运行在 Kubernetes 中，也就是说我们的 Jenkins 运行在 Docker 中。然后我们的 Jenkins 又要跑&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker build&lt;/code&gt;，那这里就会遇到很经典的 Docker in Docker 的问题。&lt;/p&gt;

&lt;p&gt;查了一些资料后，你会发现实现 Docker in Docker 并不是一个合适的方案，而且我们的问题并不是真正的 Docker in Docker 问题。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27208085&quot;&gt;使用 Docker-in-Docker 来运行 CI 或集成测试环境？三思！&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我们想要做的只是在一个 Docker 容器里去构建一个镜像，我们并不是想要在这个容器里再跑一个容器，这两个有本质的区别。&lt;/p&gt;

&lt;p&gt;如果只是想要构建一个镜像，那么能否让宿主机的 Docker 来做呢？答案是可行的！Docker 是 Client/Server 模式，并且通过 Unix Socket 通讯。&lt;/p&gt;

&lt;p&gt;看我们上面的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Jenkinsfile&lt;/code&gt;里有一行配置：&lt;/p&gt;

&lt;div class=&quot;language-groovy highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;hostPathVolume&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;mountPath:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'/var/run/docker.sock'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;hostPath:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'/var/run/docker.sock'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这行配置的作用就是把宿主机的 Docker Unix Socket 映射到容器内，这样容器内的 Docker 就可以直接和宿主机的 Docker Daemon 通讯了。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;隔离&quot;&gt;隔离&lt;/h4&gt;

&lt;p&gt;因为 Jenkins 里的跑的 Job 可以直接操作宿主机 Docker 了，而且 Jenkins 在构建的时候消耗的资源也不少，所以把 Jenkins 独立部署在一组机器上会更安全。&lt;/p&gt;

&lt;p&gt;这里很明显就要用到 Kubernetes 的&lt;a href=&quot;https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/&quot;&gt;污点和容忍性&lt;/a&gt;和&lt;a href=&quot;https://kubernetes.io/docs/concepts/configuration/assign-pod-node/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt;节点分配&lt;/a&gt;功能了。&lt;/p&gt;

&lt;p&gt;首先给 Jenkins 相关的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt;配置节点分配，让它只跑在特定的一组机器上。但这时候别的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt;也会过来运行。&lt;/p&gt;

&lt;p&gt;所以还需要给这组机器打上污点(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Taints&lt;/code&gt;)，一般的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt;都有洁癖，无法忍受这个污点，这样就不会在这台机器上跑了。&lt;/p&gt;

&lt;p&gt;接下来再在 Jenkins 相关的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt;上配置容忍性，代表着它们可以容忍这个污点。&lt;/p&gt;

&lt;p&gt;最终的效果就是只有 Jenkins 相关的 Job 可以跑在这批机器上了。&lt;/p&gt;

&lt;p&gt;具体的配置方法是打开 Jenkins 配置界面: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/configure&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;先配置一个 Jenkins Kubernetes 模版，并把它设置成默认模版，默认安装完应该就会有一个模版：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020/03/jenkins-pod-template.png&quot; alt=&quot;Jenkins Pod Template&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后再给这个模版配置容忍性：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020/03/jenkins-pod-template-yaml.png&quot; alt=&quot;Jenkins Pod Template Yaml&quot; /&gt;&lt;/p&gt;

&lt;p&gt;除此以外，这里的默认模版其实还可以做很多事情，例如上面解决 Docker in Docker 的时候手动在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Jenkinsfile&lt;/code&gt;里写了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hostPathVolume&lt;/code&gt;，其实这个可以写在模版里，所有任务就可以通用了。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;light-merge&quot;&gt;Light Merge&lt;/h4&gt;

&lt;p&gt;一些稍微大一点的项目就会有很多人一起开发，大家都在不同的分支上，但是发布的时候希望临时把这些合并一下。&lt;/p&gt;

&lt;p&gt;因为 CI / CD 脚本都是自己把控的，无非就是自己实现一些脚本可以。如果有这种需求的话只需要修改一下脚本就行了。&lt;/p&gt;

&lt;p&gt;利用 Jenkins Pipeline 相关插件可以很轻松的实现：&lt;/p&gt;

&lt;div class=&quot;language-groovy highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;sshagent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;sh&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'git config --global user.email &quot;devops@dozer.cc&quot;'&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;sh&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'git config --global user.name &quot;devops&quot;'&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;sh&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'git merge origin/feature/test'&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;从实践中总结&quot;&gt;从实践中总结&lt;/h3&gt;

&lt;p&gt;迪斯尼的小路走出来了，如果继续放任不管，最终所有路面都会被踩秃，所以及时根据反馈铺上正经的道路很重要。&lt;/p&gt;

&lt;p&gt;经过一段时间的实践后和思考后，我们觉得下面还需要做这么几件事情：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;制定标准，包括项目结构，整体流程等&lt;/li&gt;
  &lt;li&gt;重写可以通用的自动化脚本，提高开发的开发效率，也便于全局更新自动化脚本&lt;/li&gt;
  &lt;li&gt;更强大的发布控制&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;制定标准&quot;&gt;制定标准&lt;/h3&gt;

&lt;p&gt;我们基于各种实践和探索，在制定标准的过程中主要参考了如下几个原则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;和开源社区接轨&lt;/li&gt;
  &lt;li&gt;约定约于配置，减少开发的配置工作量&lt;/li&gt;
  &lt;li&gt;足够灵活，除了默认配置外允许定制化&lt;/li&gt;
  &lt;li&gt;参考 GitOps 的理念，一切配置和项目放在一起&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;明确-ci-流程&quot;&gt;明确 CI 流程&lt;/h4&gt;

&lt;p&gt;第一步要先明确一下适合我们公司的发布流程，每个公司情况都不一样，要根据自身情况来决定。&lt;/p&gt;

&lt;p&gt;我们 CI 目前大致分为这几个步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Git Push 触发&lt;/li&gt;
  &lt;li&gt;Light Merge&lt;/li&gt;
  &lt;li&gt;更新 Git 子模块&lt;/li&gt;
  &lt;li&gt;测试，编译，打包等（不同语言步骤不同）&lt;/li&gt;
  &lt;li&gt;构建 Docker 镜像&lt;/li&gt;
  &lt;li&gt;发布 Docker 镜像&lt;/li&gt;
  &lt;li&gt;构建 Helm Charts&lt;/li&gt;
  &lt;li&gt;发布 Helm Charts&lt;/li&gt;
  &lt;li&gt;通知 CD 系统&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;明确-cd-流程&quot;&gt;明确 CD 流程&lt;/h4&gt;

&lt;p&gt;CD 流程不多，但做起来却比 CI 难做，我们主要分为这几个步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;CI 触发&lt;/li&gt;
  &lt;li&gt;支持手动修改发布参数&lt;/li&gt;
  &lt;li&gt;手动发布&lt;/li&gt;
  &lt;li&gt;支持发布过程中自动金丝雀发布&lt;/li&gt;
  &lt;li&gt;支持手动回滚&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;统一项目结构&quot;&gt;统一项目结构&lt;/h4&gt;

&lt;p&gt;基于上面的 CI / CD 流程，有很多信息需要告诉对应的工具，那怎么做呢？&lt;/p&gt;

&lt;p&gt;这时候就要用到上述提到的几个原则了，例如构建 Docker 镜像用的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt;，一般都是直接放在根目录的；&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Jenkinsfile&lt;/code&gt;也是如此；Helm Chart 一般放在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;./charts/project-name&lt;/code&gt;里。&lt;/p&gt;

&lt;p&gt;先参考开源社区的最佳实践，然后再制定我们内部的约定：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;项目名称就是 Git 代码仓库的名称&lt;/li&gt;
  &lt;li&gt;Light Merge 自动合并所有 Pull Request 对应的分支&lt;/li&gt;
  &lt;li&gt;Docker 镜像名称就是项目名&lt;/li&gt;
  &lt;li&gt;Docker Image Tag 格式：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{yyyyMMddhhmm}.{short reversion}&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Helm Chart 名称就是项目名&lt;/li&gt;
  &lt;li&gt;Helm Chart 版本：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{chart version}+{image tag}&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;部署出来的服务名就是项目名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些约定大多数没什么可说的，但 Light Merge 值得说一下。&lt;/p&gt;

&lt;p&gt;最早之前，我们的 Light Merge 都是写死在各自的脚本里的，如果以后把自动化脚本抽象后，如何才能知道哪些分支要做 Light Merge 呢？&lt;/p&gt;

&lt;p&gt;一种方案是根据名字来，因为设计良好的分支模型各个分支的合并方向是固定的。在测试环境，一般就是把所有的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;feature/*&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hotfix/*&lt;/code&gt;合并到测试分支就行了。&lt;/p&gt;

&lt;p&gt;但是有些&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;feature/*&lt;/code&gt;分支还在开发中，不想在测试环境发布怎么办？&lt;/p&gt;

&lt;p&gt;后来我们想到了是否可以利用 Pull Request 来做。因为 Pull Request 是一个代表想要合并的意图，Pull Request 也是把代码提交到测试分支的必经之路，有了 Pull Request 也可以告诉对应人员需要做代码审查了。&lt;/p&gt;

&lt;p&gt;所以 Pull Request 和 Light Merge 的出现时机是完全一致的。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;统一自动化脚本&quot;&gt;统一自动化脚本&lt;/h3&gt;

&lt;p&gt;有了各种标准，那么下一步要做的就是统一自动化脚本了。 之前我们自动化脚本的最大问题就是大部分逻辑都是可以公用的，但是却在每个项目里保留了一份。&lt;/p&gt;

&lt;p&gt;一开始我们提供了一份模板给大家“抄”，但这个模版也在不断更新，很难去推动大家修改自己的模版。&lt;/p&gt;

&lt;p&gt;所以如果还是基于 Jenkins 的话如何才能尽量复用代码呢？&lt;/p&gt;

&lt;p&gt;后来我们发现，在 Jenkins Pod Template 的配置里，还可以指定默认的容器。上面&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Jenkinsfile&lt;/code&gt;的例子里用了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;maven&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;helm&lt;/code&gt;三个容器做不同的事情，但这几个都是非常基础的容器，开发还需要额外写不少代码。&lt;/p&gt;

&lt;p&gt;那我们是不是可以自己做一个 CI 镜像，然后把所有 CI 的功能集成在里面呢？&lt;/p&gt;

&lt;p&gt;答案是肯定的，经过简化后，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Jenkinsfile&lt;/code&gt;可以做到非常简化，而且又不失灵活性：&lt;/p&gt;

&lt;div class=&quot;language-groovy highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;podTemplate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;containers:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;containerTemplate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;name:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'go'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;image:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'golang:latest'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;ttyEnabled:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;command:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'cat'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;POD_LABEL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;checkout&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scm&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;stage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Before Build'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'ci'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sh&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;before_build&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;stage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Build'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'go'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sh&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;make test &amp;amp;&amp;amp; make linux&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;stage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'After Build'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'ci'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sh&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;after_build&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;before_build&lt;/code&gt;会完成 CI 流程里的 2~3，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;after_build&lt;/code&gt;会完成 CI 流程里的 5~9。&lt;/p&gt;

&lt;p&gt;需要更新 CI 自动化脚本的时候只要更新这个 CI 镜像就行了，开发不需要做任何改动。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;灵活性&quot;&gt;灵活性&lt;/h3&gt;

&lt;p&gt;自动化脚本之所以可以这么简单，是因为有了大量的约定而无法大量的配置。但只要配置是可修改的，那么灵活性同样也可以保证。&lt;/p&gt;

&lt;p&gt;例如有些项目它同一份代码可能要部署成不同的项目，那么项目名等于 Git 代码仓库名这个约定就失效了。&lt;/p&gt;

&lt;div class=&quot;language-groovy highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;podTemplate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;containers:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;containerTemplate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;name:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'go'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;image:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'golang:latest'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;ttyEnabled:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;command:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'cat'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;envVars:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;envVar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;key:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'PROJECT_NAME'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;value:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'block-service'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;POD_LABEL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;checkout&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scm&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;stage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Before Build'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'ci'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sh&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;before_build&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;stage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Build'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'go'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sh&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;make test &amp;amp;&amp;amp; make linux&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;stage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'After Build'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'ci'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sh&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;after_build&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;那这里在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Jenkinsfile&lt;/code&gt;里只需要注入环境变量就行了，非常方便。底层脚本都是根据环境变量来操作的，如果为空就按照默认约定自动生成。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;另外还有一些项目，它会在同一个项目里构建多个镜像，发布成同一个服务，那&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;after_build&lt;/code&gt;这个脚本底层其实也是调用了两外两个封装好的脚本，分别是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push_image&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push_cd&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;那只要把&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;after_build&lt;/code&gt;去掉，直接调用底层的脚本就行了：&lt;/p&gt;

&lt;p&gt;例如我们在发布一些 Python 服务的时候，就需要额外构建一个 Nginx 镜像：&lt;/p&gt;

&lt;div class=&quot;language-groovy highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Disable default after build&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// stage('After Build') {container('ci') { sh &quot;after_build&quot; }}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;stage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Build uWsgi Image'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'ci'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;push_image --name user-service-uwsgi --file docker/uwsgi/Dockerfile&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;stage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Build Nginx Image'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'ci'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;push_image --name user-service-nginx --file docker/nginx/Dockerfile&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;stage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Push to CD'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'ci'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&quot;push_cd \
            --image uwsgiImage=user-service-uwsgi \
            --image nginxImage=user-service-nginx &quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;$cmd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;更强大的发布控制&quot;&gt;更强大的发布控制&lt;/h3&gt;

&lt;p&gt;在我们做第一版 CI / CD 的时候，支持 Kubernetes 的 CD 开源工具几乎是空白。&lt;/p&gt;

&lt;p&gt;我们也尝试过自研，但因为别的项目屡屡搁置，因为要做一个好用的 CD 工具对前端水平就是一个很大的考验。&lt;/p&gt;

&lt;p&gt;“求求你，我不想再学了！”&lt;/p&gt;

&lt;p&gt;这是在每个前端框架发布后都会看到的一句话，说多了都是泪，对后端来说真的是没精力去学那么多前端框架了。&lt;/p&gt;

&lt;p&gt;还好在调研各种工具后，发现 &lt;a href=&quot;https://argoproj.github.io/argo-cd/&quot;&gt;Argo CD&lt;/a&gt; 非常好用。&lt;/p&gt;

&lt;p&gt;它可以在界面上控制各种发布参数，Helm Chart 打包出来的包在不同的环境下会有不同的配置，需要一个地方来管理。&lt;/p&gt;

&lt;p&gt;它也可以把整个发布过程做可视化，哪个环节出了问题，看日志非常方便。&lt;/p&gt;

&lt;p&gt;最实用的就是，它可以手动控制回滚到特定版本。发布的时候出问题了，只要直接手动回滚就行了。&lt;/p&gt;

&lt;p&gt;具体的用法可以看它官网的介绍。&lt;/p&gt;

&lt;p&gt;然而它也不是万能的，金丝雀发布和蓝绿发布等都没有。所以虽然我们的计划里有这部分，但目前并没有实现&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;目前为止，虽然我们新的 CI / CD 已经上线，但其实这个版本是刚完成没多久的，得到大家的试用反馈后还会有大量的问题和需求。&lt;/p&gt;

&lt;p&gt;还好目前我们的新方案中，发布脚本的变动不需要开发的改动了。&lt;/p&gt;

&lt;p&gt;可预见的其中一个需求就是金丝雀发布和蓝绿发布。虽然还没有实现，但是我们也已经有了一些方案。&lt;/p&gt;

&lt;p&gt;相关的开源框架有 &lt;a href=&quot;https://docs.flagger.app/&quot;&gt;Flagger&lt;/a&gt; 和 &lt;a href=&quot;https://argoproj.github.io/argo-rollouts/&quot;&gt;Argo Rollouts&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;这两个我们都试用过，但都还缺点东西，所以我们后续的计划应该是基于其中某个做二次开发，来满足我们自身的需求。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;另外，整个 CI / CD 的使用中，还有很多东西值得去做成约定，而不是让开发自己去写。&lt;/p&gt;

&lt;p&gt;例如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt;等，虽然有多语言，但一个同样是 Golang 的简单服务，它们的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt;几乎是没有任何区别的。&lt;/p&gt;

&lt;p&gt;所以这里还有很大的空间可以去进一步简化开发的工作量。&lt;/p&gt;
</description>
				<pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate>
				<link>/2020/03/ci-cd.html</link>
				<guid isPermaLink="true">/2020/03/ci-cd.html</guid>
			</item>
		
			<item>
				<title>Service Mesh 实践（六）：I18N Language</title>
				<description>&lt;h3 id=&quot;国际化&quot;&gt;国际化&lt;/h3&gt;

&lt;p&gt;对于一个国际化的 App 来说，UI 和各种文案的国际化是必须的。&lt;/p&gt;

&lt;p&gt;一般来说，开发只要根据用户的语言，然后调用对应方法，就可以拿到对应的文案了。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errorMessage&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getErrorMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;exception.HTTP_404&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;en-US,en;q=0.5&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;!--more--&gt;

&lt;p&gt;底层处理也很简单，大部分语言都有相关的支持。例如 Java 中文件结构可以是这样的：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
└── resources
    └── i18n
        ├── exception_ar.properties
        ├── exception_en.properties
        ├── exception_es.properties
        ├── exception_fr.properties
        ├── exception_ko.properties
        ├── exception_pt.properties
        └── exception_ru.properties
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用的时候底层只要这么调用就行了：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;ResourceBundle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getBundle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i18n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exception&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;en-US,en;q=0.5&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;HTTP_404&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;开发维护&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exception_en.properties&lt;/code&gt;文件，可以通过脚本把英文文案上传到对应的翻译平台，然后其他的语言是在翻译平台翻译好后下载下来的。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;i18n-service&quot;&gt;I18N Service&lt;/h3&gt;

&lt;p&gt;微服务化后，如果还是每个项目自己做国际化，这种模式就出现问题了。&lt;/p&gt;

&lt;p&gt;首先，如何在下游服务中拿到用户的语言？你要解决吧也不难，所有服务透传用户语言就行了，大部分 RPC 框架可以透传整个调用链的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;context&lt;/code&gt;。但我们目前是 HTTP + gRPC，这个对我们来说很麻烦。&lt;/p&gt;

&lt;p&gt;第二个问题是，如果每个要做国际化的项目都要处理文案上传，下载，那是不是也很麻烦？&lt;/p&gt;

&lt;p&gt;那既然微服务化了，那这种通用的功能就应该做成一个服务来解决吧？&lt;/p&gt;

&lt;p&gt;可是做成服务并不能解决第一个问题，而且做成服务反而多了很多麻烦的地方，例如如果你调用 I18N Service 失败了怎么处理？嗯，我在处理一个异常的时候发生了异常… 而且性能上也是一个问题。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;处理过程前置&quot;&gt;处理过程前置&lt;/h3&gt;

&lt;p&gt;生成国际化的文案需要两个信息，一个是具体的文案的代号，代号可以是上面提到的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exception.HTTP_404&lt;/code&gt;这种格式，也可以直接用英文文案&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exception.Page Not Found&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;我不太喜欢直接用英文的文案在代码里做文案的代号，因为里面可能会有特殊字符要处理，英文文案也有可能会变。文案变了要改代码，这个我无法接受。&lt;/p&gt;

&lt;p&gt;文案的代号会在各个服务中产生，不分层次。&lt;/p&gt;

&lt;p&gt;生成国际化文案另一个需要的信息是用户语言，这个信息离用户越近越容易拿到。抛开做国际化，下层服务理论上根本不用关心这个信息。&lt;/p&gt;

&lt;p&gt;既然用户语言离用户越近越容易拿到，那么哪一层离用户最近？那当然是用户的手机 App 代码了！&lt;/p&gt;

&lt;p&gt;所以，是否可以在 Server 返回一些代号，然后 Client 去解析并读取对应的文案？&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;流程设计&quot;&gt;流程设计&lt;/h4&gt;

&lt;p&gt;那我们就不要在 Server 做任何翻译了，通过一些模版语言把国际化文案的代号告诉 Client 就行了：&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;errorMessage&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;{exception.USER_NOT_FOUND}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;errorCode&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;110&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因为 Server 会不断新增文案，所以 Client 无法把翻译文件都整合在本地，需要再调用一个 Server 的 API 去获得用户对应语言的翻译就行了。&lt;/p&gt;

&lt;p&gt;转换好后变成如下内容：&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;errorMessage&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;用户不存在！&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;errorCode&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;110&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这部分文案完全可以长时间在本地缓存，虽然多了一次远程调用，因为翻译变动非常少，所以缓存命中率会很高。&lt;/p&gt;

&lt;p&gt;别的优化策略还有很多，例如 Server 可以分析 Client 对各种文案的调用频率，提前下发高频文案给 Client，这样也能大大优化 Client 性能。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;兼容现有代码&quot;&gt;兼容现有代码&lt;/h3&gt;

&lt;p&gt;上述方案如果在一个全新的项目中采用我觉得是没什么问题的，但是如果不是一个新 App 怎么办呢？&lt;/p&gt;

&lt;p&gt;是否可以把干这个活的下放一层呢？我们不是有 API Gateway 吗？&lt;/p&gt;

&lt;p&gt;之前介绍过我们 API Gateway 的发展历程：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/2020/02/api-gateway.html&quot;&gt;Service Mesh 实践（四）：从开源 Ingress 到自研 API Gateway&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;有了 API Gateway 后就可以很好地解决这个问题了！既不需要 Client 改代码，也可以集中处理集群内所有的流量。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;流程设计-1&quot;&gt;流程设计&lt;/h4&gt;

&lt;p&gt;实现思路和上面的思路差不多，但这里可以画张图，更清晰一点：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020/03/i18n.png&quot; alt=&quot;I18N&quot; /&gt;&lt;/p&gt;

&lt;p&gt;整个处理流程差不多就是这样了，那现在最大的问题就是，应该如何设计这个模版语言？&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;i18n-language&quot;&gt;I18N Language&lt;/h3&gt;

&lt;p&gt;其实，在上面的例子中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{exception.USER_NOT_FOUND}&lt;/code&gt;已经是一个最简单的语法了，但很明显这个简单的表达式是不够的。&lt;/p&gt;

&lt;p&gt;我把我们项目里所有的翻译都排摸了一遍，总结了一下我们遇到的需求，并全部设计了一下。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;参数化&quot;&gt;参数化&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{exception.USER_NOT_FOUND}&lt;/code&gt; 会转换成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;用户不存在！&lt;/code&gt;，那如果想要变成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;用户 Dozer 不存在！&lt;/code&gt;呢？&lt;/p&gt;

&lt;p&gt;也就是说文案中要支持传入参数。以前，这种参数化的需求一般会在最终翻译的文案里放一些占位符，例如：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;用户 {nickname} 不存在！&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;以前业务代码的处理流程是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;根据&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exception.USER_NOT_FOUND&lt;/code&gt;读取到文案&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;用户 {nickname} 不存在！&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;把文案中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{nickname}&lt;/code&gt;替换掉&lt;/li&gt;
  &lt;li&gt;返回文案&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;改造后业务代码直接返回：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{exception.USER_NOT_FOUND}&lt;/code&gt;，API Gateway 读取文案并处理，那是不是少传递了点信息？&lt;/p&gt;

&lt;p&gt;是的，API Gateway 不知道&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nickname&lt;/code&gt;应该被替换成什么。&lt;/p&gt;

&lt;p&gt;所以最终语法可以变成这样：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{exception.USER_NOT_FOUND,nickname=Dozer}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;API Gateway 拿到翻译后的文案后，发现业务代码额外传了一些参数，就会去文案中把对应的占位符替换掉了。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;默认值&quot;&gt;默认值&lt;/h4&gt;

&lt;p&gt;不同语言翻译的进度是不一样的，一般业务上线后，一些小众语言并不会翻译完，这时候会把英文的文案暂时返回给用户。&lt;/p&gt;

&lt;p&gt;但这里的默认值指的不是这个。&lt;/p&gt;

&lt;p&gt;这里的默认值指的是，有些文案连英文的翻译都没有。&lt;/p&gt;

&lt;p&gt;举个例子：我们商店里的商品需要翻译，但商品和上面遇到的异常不一样，异常是伴随着代码一起产生的，而商品是会在代码上线后，在后台新配置的。按照我们的工作流程，这种商品后续会定期有对应的脚本提取出来英文文案，然后提交到翻译平台，最终再翻译成各种别的语言。&lt;/p&gt;

&lt;p&gt;在这个空窗期中，这个商品是没有任何翻译的，包括英文。&lt;/p&gt;

&lt;p&gt;所以遇到这样的场景，需要传递一个默认翻译的信息，如果有翻译就用，没有就用默认值。&lt;/p&gt;

&lt;p&gt;语法可以是这样的：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{product.sticker_name_1=长草团子}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;嵌套翻译&quot;&gt;嵌套翻译&lt;/h4&gt;

&lt;p&gt;我们有一类文案，场景是显示订单信息，内容是：订阅了商品一、订阅了商品二、退订了商品一。这句文案分为两部分，前面的动词和后面的名字。&lt;/p&gt;

&lt;p&gt;上面提到的参数化可以把商品名作为一个参数传进去，但是传进去的参数就是最终文案了。只适合用户名这种不需要翻译的内容。&lt;/p&gt;

&lt;p&gt;如果参数也需要做翻译怎么办？就像高阶函数，那就实现嵌套翻译吧！&lt;/p&gt;

&lt;p&gt;语法也不难，这样设计就行：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{order_history.buy_product,product={product.sticker_name_1=长草团子}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;完整语法&quot;&gt;完整语法&lt;/h4&gt;

&lt;p&gt;最后，完整的语法如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{i18n-key-name[=fallback-value][,argument-key1=argument-value1][,argument-key2={another-i18n-key-name}]}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[ ]&lt;/code&gt;里的内容代表可选参数&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{ }&lt;/code&gt;可以替换成别的符号，根据自己的需求来设计&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;语法解析&quot;&gt;语法解析&lt;/h4&gt;

&lt;p&gt;语法设计好了，业务代码只要实现语法生成就行了，只是一些简单的文本拼接，根本不需要任何 SDK。只要注意按照约定做一些转义。&lt;/p&gt;

&lt;p&gt;例如上面你把用户的昵称放到了表达式中，用户输入的数据必定是不可靠的，你需要把&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{ } ,&lt;/code&gt;等符号做转义，否则会影响解析的结果。&lt;/p&gt;

&lt;p&gt;具体解析算法的实现就参考编译原理，用有限状态机实现一下就行了。这部分的解析性能是非常高的，把表达式遍历一遍就可以完成，也就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(n)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;然后 API Gateway 再配合一些缓存策略，整体的性能就几乎没有影响了。&lt;/p&gt;
</description>
				<pubDate>Wed, 04 Mar 2020 00:00:00 +0000</pubDate>
				<link>/2020/03/i18n-language.html</link>
				<guid isPermaLink="true">/2020/03/i18n-language.html</guid>
			</item>
		
			<item>
				<title>Service Mesh 实践（五）：优雅启动和优雅关闭</title>
				<description>&lt;h3 id=&quot;传统做法&quot;&gt;传统做法&lt;/h3&gt;

&lt;p&gt;以前的微服务架构中优雅启动和优雅关闭其实不难，这些东西本身就是自己实现的。&lt;/p&gt;

&lt;p&gt;启动后先打点流量预热一下，然后把实例注册一下就行了；要关闭的时候就先取消注册，等待一段时间尽量让所有请求结束后再关闭。&lt;/p&gt;

&lt;p&gt;另外，传统微服务架构下的实例启动关闭的频率也远低于 Service Mesh，做了 Service Mesh 这个问题也会更突出一点。&lt;/p&gt;

&lt;p&gt;那具体遇到了哪些问题又怎么解决呢？&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;golang--istio-启动失败&quot;&gt;Golang + Istio 启动失败&lt;/h3&gt;

&lt;p&gt;这个问题是我们第一个遇到的，现象就是每次发布，新的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt;总是会出错一次，然后 Kubernetes 把它重启后再来一次就好了。&lt;/p&gt;

&lt;p&gt;而且只有 Golang 程序有这个问题，Java 程序不会有。&lt;/p&gt;

&lt;p&gt;重现步骤不难，先在集群内装好 Istio 再装一个最简单的 Nginx Server。&lt;/p&gt;

&lt;p&gt;然后再写个简单的 Golang 程序，启动的时候立刻访问 Nginx 就可以了。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;net/http&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;healthCheck&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;ok&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://nginx/&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
		&lt;span class=&quot;nb&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Start Simple Http Server&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HandleFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/health-check&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;healthCheck&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ListenAndServe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;:8080&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然而你会发现，Golang 写的程序总是大概率在第一次启动的时候失败，Kubernetes 把它重启一次后才会正常。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NAME                          READY   STATUS         RESTARTS   AGE
app-tester-7b999ff58c-4l7zb   2/2     Running        1          81s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;查看&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt;状态后发现是程序挂掉了，这时候日志还不容易看，因为容器已经重启了，直接看的话看到的是最新的日志。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl describe pods app-tester-7b999ff58c-4l7zb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Containers:
  app-tester:
    Container ID:  docker://2ef6f6bb8af84aca41f8d67ed30a348f528a6066260e8e2373f530e7d71a4c0d
    Image:         golang
    Image ID:      docker-pullable://golang@sha256:72218b6a9e51cbbd91980fb8c770b6a577e2165defcbb838108df96f58898d25
    Port:          8080/TCP
    Host Port:     0/TCP
    Command:
      ./run
    State:          Terminated
      Reason:       Error
      Exit Code:    1
      Started:      Thu, 27 Feb 2020 18:56:48 +0800
      Finished:     Thu, 27 Feb 2020 18:56:49 +0800
    Ready:          False
    Restart Count:  0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果你已经在集群内装了 Fluent Bit 等搜集日志的服务，那么可以很方便地看到重启前的日志了，如果没有，那么还需要登陆宿主机去找日志。&lt;/p&gt;

&lt;p&gt;最后我们发现，是启动一瞬间的网络有问题，所以导致无法访问。&lt;/p&gt;

&lt;p&gt;因为只有配合 Istio 才有问题，搜索后找到了对应的 Issue：&lt;a href=&quot;https://github.com/istio/istio/issues/11130&quot;&gt;https://github.com/istio/istio/issues/11130&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;原来，根本原因是 Envoy 还未启动完成的时候我们的业务就进行了网络请求导致的。因为 Istio 利用 Init Container 通过 iptables 早就把所有出口流量指向了 Envoy，如果 Envoy 还未启动完成，业务代码自然是无法进行网络请求的。&lt;/p&gt;

&lt;p&gt;总结起来就是一句话，Golang 启动太快了！那 Java 为什么没问题了？因为 Java 启动太慢了，至少几十秒，自然就不会出现这个现象了。&lt;/p&gt;

&lt;p&gt;目前我们的解决办法也很简单粗暴，所有 Golang 程序启动前 sleep 3 秒就解决了。另外也可以修改&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Deployment&lt;/code&gt;，加一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lifecycle.preStart&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sleep&lt;/code&gt;几秒就行了。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;istio-优雅关闭&quot;&gt;Istio 优雅关闭&lt;/h3&gt;

&lt;p&gt;另一个问题更难解决一点，是主要是程序关闭的时候遇到地问题。&lt;/p&gt;

&lt;p&gt;第一种现象是如果 A 访问 B，B再访问 C，此时一个请求正在等 C 处理，A 和 B 都在等待。如果关闭了 B，A 的这次请求就失败了。&lt;/p&gt;

&lt;p&gt;理论上如果 B 程序处理地好，等待所有请求都结束后再终止程序，不应该有问题的。&lt;/p&gt;

&lt;p&gt;可惜注入了 Envoy 后，Envoy 在这块处理地并不好。Envoy 在收到终止信号的时候立刻退出了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/istio/istio/issues/7136&quot;&gt;https://github.com/istio/istio/issues/7136&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;相关地讨论很多，Envoy 和 Istio 后来已经解决了这个问题，这个问题比较好解决，一个设计良好地程序就应该支持优雅关闭。&lt;/p&gt;

&lt;p&gt;但还有一个类似的问题就比较尴尬了。&lt;/p&gt;

&lt;p&gt;如果 A 访问 B，B 再访问 C，此时如果一个请求正在进行中，B 正在处理自己的东西，还未请求 C。&lt;/p&gt;

&lt;p&gt;这时候把 B 终止，B 的代码还在继续跑，当它想要请求 C 的时候，网络却不通了。&lt;/p&gt;

&lt;p&gt;因为收到终止信号的时候 B 注入的 Envoy 没有活跃链接了，它也不会知道 B 还会不会再请求，所以它就退出了。&lt;/p&gt;

&lt;p&gt;我们一开始用了一种简单粗暴的解决办法，修改了 Istio 代码，强制让 Envoy 在退出前 sleep 几秒，这种现象就会大大改善了。&lt;/p&gt;

&lt;p&gt;最新新发布的 Istio 1.4 中已经支持通过参数修改 Envoy 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lifecycle&lt;/code&gt; 了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020/02/injection-template.png&quot; alt=&quot;Injection Template&quot; /&gt;&lt;/p&gt;

&lt;p&gt;修改方法很简单，在 Istio 配置中加入这部分就行了：&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;global&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;proxy&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;lifecycle&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;preStop&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;/bin/sh&quot;&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;-c&quot;&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;15&quot;&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但是文档还没更新，应该是还没来得及。其实我本来在写博客的时候也不知道这个变了，我只是想说一下应该改哪，翻阅源码的时候才看到它们已经支持了。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;kubernetes-对-sidecar-的支持&quot;&gt;Kubernetes 对 Sidecar 的支持&lt;/h3&gt;

&lt;p&gt;真的要解决上面两个问题还是需要 Kubernetes 官方的支持了，因为同一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt;中多个容器一般都是有一些依赖关系的，没有启动顺序这个功能的话会出很多问题。值得高兴的是，Kubernetes 准备在 1.18 中支持这种场景了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://banzaicloud.com/blog/k8s-sidecars/&quot;&gt;https://banzaicloud.com/blog/k8s-sidecars/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;1.18 中你可以把一个容器标记成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sidecar&lt;/code&gt;，它会保证一定在你的程序启动前完成启动，也会保证在你的容器关闭后再关闭自己。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020/02/sidecar-lifecycle-2.gif&quot; alt=&quot;sidecar-lifecycle-2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;有了这个功能后，就能完美解决上面几个问题了。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;java-程序启动时负载过高延迟过大&quot;&gt;Java 程序启动时负载过高延迟过大&lt;/h3&gt;

&lt;p&gt;Golang 的问题是启动太快了，而 Java 的问题就是启动太慢了…&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;kubernetes-资源配置与自动扩容缩容&quot;&gt;Kubernetes 资源配置与自动扩容缩容&lt;/h4&gt;

&lt;p&gt;Kubernetes 的最佳实践中，要为所有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt;配置容器的资源请求和限制，细节可以看官方文档：&lt;a href=&quot;https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/&quot;&gt;https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;简单概括一下就是你要为你的容器配置四个参数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;resources.limits.cpu&lt;/code&gt;: 容器最多可以用多少 CPU&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;resources.limits.memory&lt;/code&gt;: 容器最多可以用多少内存&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;resources.requests.cpu&lt;/code&gt;: 为容器保留多少 CPU&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;resources.requests.memory&lt;/code&gt;: 为容器保留多少内存&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;resources.limits&lt;/code&gt;下的两个参数底层就是用 cgroup 来做限制的，容器的 CPU 不可能超过这个值，内存超过了会 OOM。&lt;/p&gt;

&lt;p&gt;而&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;resources.requests&lt;/code&gt;下的两个参数是 Kubernetes 在机器上分配容器的时候用的。如果机器是 4 核，那么最多只能跑 4 个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;resources.requests.cpu=1&lt;/code&gt;的容器。&lt;/p&gt;

&lt;p&gt;那&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;resources.limits&lt;/code&gt;大于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;resources.requests&lt;/code&gt;会发生什么？这个其实就相当于超售了，因为大部分业务声明给自己保留 1 核 CPU 的时候，它大部分时间不能跑满。&lt;/p&gt;

&lt;p&gt;CPU 超售问题不大，最多就是大家都慢一点而已，这只是应对突发情况用的。但是内存超售就不容易出事了，很容易导致 OOM。所以一般内存不会超售。&lt;/p&gt;

&lt;p&gt;然后为了充分利用资源，一般都是配置&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HorizontalPodAutoscaler&lt;/code&gt;来实现自动扩容缩容，Kubernetes 可以根据你声明的资源数和实际使用的资源数做比较，如果用的很少就会缩容，如果用的多了就会扩容。&lt;/p&gt;

&lt;p&gt;在低峰期我们的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt;就会自动缩容，把资源让出来给数据平台，这样可以节约不少钱。&lt;/p&gt;

&lt;p&gt;但是到了高峰期，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt;开始扩容的时候 P90 总会飙得非常高。一般一个平均延迟 10ms 的服务在扩容的时候 P90 会达到 100ms 以上，并发大的服务最慢的时候甚至会到秒级。&lt;/p&gt;

&lt;p&gt;当一个业务要更新代码的时候，也同样有类似的问题，总会导致上游调用方有少量报错。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;为什么在-kubernetes-里会有问题&quot;&gt;为什么在 Kubernetes 里会有问题&lt;/h4&gt;

&lt;p&gt;Service Mesh 很多服务都是轻量级的，一般一个简单的 Java 服务资源配置大致是这样的：&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;resources&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;requests&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;cpu&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;memory&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;512Mi&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;limits&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;cpu&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1.5&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;memory&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;512Mi&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个在运行的时候没问题，CPU 额外超售了 50%，也不会太影响同一台机器上的别的业务。但在刚启动的时候编译过程中，需要大量 CPU 就显得力不从心了。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;requests.limits.cpu&lt;/code&gt;配置得太大会影响别的业务，配置得太小又会导致启动过程中 CPU 不够用无法快速响应请求。&lt;/p&gt;

&lt;p&gt;而微服务架构下的服务一般不会拆那么小，也不可能跑在那么小的虚拟机下，所以这个现象不会非常明显。&lt;/p&gt;

&lt;p&gt;另外 Kubernetes 内置&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Service&lt;/code&gt;，或是用了 Istio 以后的 Envoy，它们的负载均衡策略都是随机分配。所以如果一共有 3 个实例，当新启动一个后变成了 4 个，新的实例会一瞬间分配到 25% 的流量。&lt;/p&gt;

&lt;p&gt;而微服务下的服务治理框架可以灵活地给新启动的业务分配流量缓解这个现象。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;尝试分层编译优化&quot;&gt;尝试分层编译优化&lt;/h4&gt;

&lt;p&gt;先试试从源头解决这个问题，看过 JVM 原理的一定能猜到这是 Java 即时编译导致的。新版本的 Java 已经废弃了老的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-client&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-server&lt;/code&gt;两个参数，而是利用分层编译把&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c1&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c2&lt;/code&gt;两个编译器配合使用了。具体细节可以看这篇文章：&lt;a href=&quot;http://zhongmingmao.me/2019/01/02/jvm-advanced-jit/&quot;&gt;JVM进阶 – 浅谈即时编译&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;基于 Java 1.8+，根据原理，我有几个方案：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;跳过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c1&lt;/code&gt;，代码运行后直接用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c2&lt;/code&gt;，类似以前的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-server&lt;/code&gt;模式，对应参数：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-XX:-TieredCompilation&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c1&lt;/code&gt;就停止，不会进行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c2&lt;/code&gt;，类似以前的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-client&lt;/code&gt;模式，对应参数：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-XX:TieredStopAtLevel=1&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我写了个简单的 Java Server，暴露一个 API，每次请求会访问一次数据库。代码里用到了 Spring MVC，Mybatis，所以这个看似简单的程序背后有大量的 class 需要被编译。&lt;/p&gt;

&lt;p&gt;然后限制 CPU 使用最多 0.5 核。再用压测工具每间 10 秒压测一轮记录下相关参数。另外我也控制了 QPS，保证在预热完成后实际 CPU 占用大约在 0.3 核左右。&lt;/p&gt;

&lt;p&gt;测试脚本很简单：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;n &lt;span class=&quot;o&quot;&gt;({&lt;/span&gt;1..50&lt;span class=&quot;o&quot;&gt;})&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;fortio load &lt;span class=&quot;nt&quot;&gt;-quiet&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-qps&lt;/span&gt; 1000 &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; 100 &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; 10s  http://app-tester:8080/ &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下面是测试结果：&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# openjdk8 默认参数&lt;/span&gt;
java &lt;span class=&quot;nt&quot;&gt;-jar&lt;/span&gt; app-tester.jar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Time&lt;/th&gt;
      &lt;th&gt;P50&lt;/th&gt;
      &lt;th&gt;P75&lt;/th&gt;
      &lt;th&gt;P90&lt;/th&gt;
      &lt;th&gt;P99&lt;/th&gt;
      &lt;th&gt;P99.9&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0s&lt;/td&gt;
      &lt;td&gt;197.4&lt;/td&gt;
      &lt;td&gt;465.625&lt;/td&gt;
      &lt;td&gt;826.97&lt;/td&gt;
      &lt;td&gt;1886.29&lt;/td&gt;
      &lt;td&gt;2544.86&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;10s&lt;/td&gt;
      &lt;td&gt;182.765&lt;/td&gt;
      &lt;td&gt;238.632&lt;/td&gt;
      &lt;td&gt;446.176&lt;/td&gt;
      &lt;td&gt;995.955&lt;/td&gt;
      &lt;td&gt;1812.9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;20s&lt;/td&gt;
      &lt;td&gt;99.205&lt;/td&gt;
      &lt;td&gt;160.3&lt;/td&gt;
      &lt;td&gt;267.201&lt;/td&gt;
      &lt;td&gt;1503.85&lt;/td&gt;
      &lt;td&gt;2551.17&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;30s&lt;/td&gt;
      &lt;td&gt;95.7119&lt;/td&gt;
      &lt;td&gt;106.129&lt;/td&gt;
      &lt;td&gt;183.418&lt;/td&gt;
      &lt;td&gt;503.273&lt;/td&gt;
      &lt;td&gt;758.72&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;40s&lt;/td&gt;
      &lt;td&gt;54.4359&lt;/td&gt;
      &lt;td&gt;89.8943&lt;/td&gt;
      &lt;td&gt;99.8245&lt;/td&gt;
      &lt;td&gt;193.144&lt;/td&gt;
      &lt;td&gt;246.976&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;50s&lt;/td&gt;
      &lt;td&gt;63.6049&lt;/td&gt;
      &lt;td&gt;94.1969&lt;/td&gt;
      &lt;td&gt;108.253&lt;/td&gt;
      &lt;td&gt;192.8&lt;/td&gt;
      &lt;td&gt;280.769&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;60s&lt;/td&gt;
      &lt;td&gt;55.2794&lt;/td&gt;
      &lt;td&gt;80.7453&lt;/td&gt;
      &lt;td&gt;95.5563&lt;/td&gt;
      &lt;td&gt;238.682&lt;/td&gt;
      &lt;td&gt;414.314&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;70s&lt;/td&gt;
      &lt;td&gt;70.991&lt;/td&gt;
      &lt;td&gt;97.7175&lt;/td&gt;
      &lt;td&gt;134.101&lt;/td&gt;
      &lt;td&gt;558.424&lt;/td&gt;
      &lt;td&gt;1571.53&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;80s&lt;/td&gt;
      &lt;td&gt;53.8337&lt;/td&gt;
      &lt;td&gt;83.1865&lt;/td&gt;
      &lt;td&gt;96.9365&lt;/td&gt;
      &lt;td&gt;175.921&lt;/td&gt;
      &lt;td&gt;276.923&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;90s&lt;/td&gt;
      &lt;td&gt;55.6827&lt;/td&gt;
      &lt;td&gt;83.9577&lt;/td&gt;
      &lt;td&gt;99.0229&lt;/td&gt;
      &lt;td&gt;285.921&lt;/td&gt;
      &lt;td&gt;616.3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;100s&lt;/td&gt;
      &lt;td&gt;68.2399&lt;/td&gt;
      &lt;td&gt;91.0623&lt;/td&gt;
      &lt;td&gt;99.4049&lt;/td&gt;
      &lt;td&gt;450.0&lt;/td&gt;
      &lt;td&gt;1210.88&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;110s&lt;/td&gt;
      &lt;td&gt;9.45747&lt;/td&gt;
      &lt;td&gt;22.6015&lt;/td&gt;
      &lt;td&gt;38.6823&lt;/td&gt;
      &lt;td&gt;89.0323&lt;/td&gt;
      &lt;td&gt;134.074&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;120s&lt;/td&gt;
      &lt;td&gt;6.56564&lt;/td&gt;
      &lt;td&gt;9.21653&lt;/td&gt;
      &lt;td&gt;11.3129&lt;/td&gt;
      &lt;td&gt;17.7818&lt;/td&gt;
      &lt;td&gt;51.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;130s&lt;/td&gt;
      &lt;td&gt;6.38191&lt;/td&gt;
      &lt;td&gt;8.77066&lt;/td&gt;
      &lt;td&gt;11.1053&lt;/td&gt;
      &lt;td&gt;16.1176&lt;/td&gt;
      &lt;td&gt;20.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;140s&lt;/td&gt;
      &lt;td&gt;6.35324&lt;/td&gt;
      &lt;td&gt;8.74876&lt;/td&gt;
      &lt;td&gt;10.9444&lt;/td&gt;
      &lt;td&gt;15.0841&lt;/td&gt;
      &lt;td&gt;19.9286&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;150s&lt;/td&gt;
      &lt;td&gt;5.90095&lt;/td&gt;
      &lt;td&gt;8.38842&lt;/td&gt;
      &lt;td&gt;10.4839&lt;/td&gt;
      &lt;td&gt;101.412&lt;/td&gt;
      &lt;td&gt;230.556&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;160s&lt;/td&gt;
      &lt;td&gt;6.2864&lt;/td&gt;
      &lt;td&gt;8.5492&lt;/td&gt;
      &lt;td&gt;10.8375&lt;/td&gt;
      &lt;td&gt;17.7391&lt;/td&gt;
      &lt;td&gt;23.3668&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;170s&lt;/td&gt;
      &lt;td&gt;6.47078&lt;/td&gt;
      &lt;td&gt;8.4787&lt;/td&gt;
      &lt;td&gt;10.6983&lt;/td&gt;
      &lt;td&gt;13.8976&lt;/td&gt;
      &lt;td&gt;16.7143&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;180s&lt;/td&gt;
      &lt;td&gt;6.18094&lt;/td&gt;
      &lt;td&gt;8.41088&lt;/td&gt;
      &lt;td&gt;10.6717&lt;/td&gt;
      &lt;td&gt;16.2474&lt;/td&gt;
      &lt;td&gt;19.1111&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;190s&lt;/td&gt;
      &lt;td&gt;6.40341&lt;/td&gt;
      &lt;td&gt;8.61996&lt;/td&gt;
      &lt;td&gt;10.7623&lt;/td&gt;
      &lt;td&gt;14.9554&lt;/td&gt;
      &lt;td&gt;16.7245&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;200s&lt;/td&gt;
      &lt;td&gt;5.82933&lt;/td&gt;
      &lt;td&gt;8.4235&lt;/td&gt;
      &lt;td&gt;11.1083&lt;/td&gt;
      &lt;td&gt;17.7143&lt;/td&gt;
      &lt;td&gt;20.0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020/02/latency-openjdk8-normal.png&quot; alt=&quot;Latency&quot; /&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# openjdk8 直接用`c2`&lt;/span&gt;
java &lt;span class=&quot;nt&quot;&gt;-XX&lt;/span&gt;:-TieredCompilation &lt;span class=&quot;nt&quot;&gt;-jar&lt;/span&gt; app-tester.jar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Time&lt;/th&gt;
      &lt;th&gt;P50&lt;/th&gt;
      &lt;th&gt;P75&lt;/th&gt;
      &lt;th&gt;P90&lt;/th&gt;
      &lt;th&gt;P99&lt;/th&gt;
      &lt;th&gt;P99.9&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0s&lt;/td&gt;
      &lt;td&gt;453.606&lt;/td&gt;
      &lt;td&gt;927.703&lt;/td&gt;
      &lt;td&gt;1655.03&lt;/td&gt;
      &lt;td&gt;2595.36&lt;/td&gt;
      &lt;td&gt;2863.36&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;10s&lt;/td&gt;
      &lt;td&gt;371.242&lt;/td&gt;
      &lt;td&gt;544.75&lt;/td&gt;
      &lt;td&gt;800.857&lt;/td&gt;
      &lt;td&gt;1824.29&lt;/td&gt;
      &lt;td&gt;1989.57&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;20s&lt;/td&gt;
      &lt;td&gt;277.313&lt;/td&gt;
      &lt;td&gt;396.031&lt;/td&gt;
      &lt;td&gt;629.881&lt;/td&gt;
      &lt;td&gt;1966.02&lt;/td&gt;
      &lt;td&gt;3400.33&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;30s&lt;/td&gt;
      &lt;td&gt;217.866&lt;/td&gt;
      &lt;td&gt;318.429&lt;/td&gt;
      &lt;td&gt;462.0&lt;/td&gt;
      &lt;td&gt;1531.89&lt;/td&gt;
      &lt;td&gt;1965.35&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;40s&lt;/td&gt;
      &lt;td&gt;193.299&lt;/td&gt;
      &lt;td&gt;260.764&lt;/td&gt;
      &lt;td&gt;393.448&lt;/td&gt;
      &lt;td&gt;1362.96&lt;/td&gt;
      &lt;td&gt;2096.43&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;50s&lt;/td&gt;
      &lt;td&gt;113.403&lt;/td&gt;
      &lt;td&gt;195.336&lt;/td&gt;
      &lt;td&gt;301.646&lt;/td&gt;
      &lt;td&gt;1633.06&lt;/td&gt;
      &lt;td&gt;2397.96&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;60s&lt;/td&gt;
      &lt;td&gt;99.6747&lt;/td&gt;
      &lt;td&gt;181.452&lt;/td&gt;
      &lt;td&gt;204.595&lt;/td&gt;
      &lt;td&gt;575.091&lt;/td&gt;
      &lt;td&gt;1527.4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;70s&lt;/td&gt;
      &lt;td&gt;98.4652&lt;/td&gt;
      &lt;td&gt;113.605&lt;/td&gt;
      &lt;td&gt;191.653&lt;/td&gt;
      &lt;td&gt;357.446&lt;/td&gt;
      &lt;td&gt;547.8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;80s&lt;/td&gt;
      &lt;td&gt;94.7329&lt;/td&gt;
      &lt;td&gt;103.684&lt;/td&gt;
      &lt;td&gt;181.441&lt;/td&gt;
      &lt;td&gt;225.585&lt;/td&gt;
      &lt;td&gt;372.63&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;90s&lt;/td&gt;
      &lt;td&gt;39.6047&lt;/td&gt;
      &lt;td&gt;74.4492&lt;/td&gt;
      &lt;td&gt;93.5422&lt;/td&gt;
      &lt;td&gt;184.138&lt;/td&gt;
      &lt;td&gt;242.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;100s&lt;/td&gt;
      &lt;td&gt;6.47826&lt;/td&gt;
      &lt;td&gt;8.70323&lt;/td&gt;
      &lt;td&gt;11.0&lt;/td&gt;
      &lt;td&gt;15.3176&lt;/td&gt;
      &lt;td&gt;17.641&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;110s&lt;/td&gt;
      &lt;td&gt;6.47217&lt;/td&gt;
      &lt;td&gt;8.58247&lt;/td&gt;
      &lt;td&gt;10.2566&lt;/td&gt;
      &lt;td&gt;13.3855&lt;/td&gt;
      &lt;td&gt;20.8732&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;120s&lt;/td&gt;
      &lt;td&gt;6.52315&lt;/td&gt;
      &lt;td&gt;8.65213&lt;/td&gt;
      &lt;td&gt;10.4059&lt;/td&gt;
      &lt;td&gt;14.466&lt;/td&gt;
      &lt;td&gt;17.2222&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;130s&lt;/td&gt;
      &lt;td&gt;6.51371&lt;/td&gt;
      &lt;td&gt;8.95079&lt;/td&gt;
      &lt;td&gt;12.8831&lt;/td&gt;
      &lt;td&gt;491.522&lt;/td&gt;
      &lt;td&gt;1664.8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;140s&lt;/td&gt;
      &lt;td&gt;7.44685&lt;/td&gt;
      &lt;td&gt;10.3701&lt;/td&gt;
      &lt;td&gt;15.9692&lt;/td&gt;
      &lt;td&gt;95.098&lt;/td&gt;
      &lt;td&gt;116.327&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;150s&lt;/td&gt;
      &lt;td&gt;5.81025&lt;/td&gt;
      &lt;td&gt;8.21096&lt;/td&gt;
      &lt;td&gt;10.4226&lt;/td&gt;
      &lt;td&gt;14.5373&lt;/td&gt;
      &lt;td&gt;186.301&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;160s&lt;/td&gt;
      &lt;td&gt;5.97931&lt;/td&gt;
      &lt;td&gt;8.5613&lt;/td&gt;
      &lt;td&gt;11.2288&lt;/td&gt;
      &lt;td&gt;14.9781&lt;/td&gt;
      &lt;td&gt;17.7391&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;170s&lt;/td&gt;
      &lt;td&gt;6.2186&lt;/td&gt;
      &lt;td&gt;8.42152&lt;/td&gt;
      &lt;td&gt;10.5688&lt;/td&gt;
      &lt;td&gt;16.7727&lt;/td&gt;
      &lt;td&gt;103.343&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;180s&lt;/td&gt;
      &lt;td&gt;5.77665&lt;/td&gt;
      &lt;td&gt;8.2974&lt;/td&gt;
      &lt;td&gt;10.6585&lt;/td&gt;
      &lt;td&gt;14.3762&lt;/td&gt;
      &lt;td&gt;20.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;190s&lt;/td&gt;
      &lt;td&gt;6.06703&lt;/td&gt;
      &lt;td&gt;8.39861&lt;/td&gt;
      &lt;td&gt;10.6397&lt;/td&gt;
      &lt;td&gt;15.7522&lt;/td&gt;
      &lt;td&gt;19.3684&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;200s&lt;/td&gt;
      &lt;td&gt;6.72526&lt;/td&gt;
      &lt;td&gt;8.69675&lt;/td&gt;
      &lt;td&gt;10.2719&lt;/td&gt;
      &lt;td&gt;14.422&lt;/td&gt;
      &lt;td&gt;16.4739&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020/02/latency-openjdk8-tier-4.png&quot; alt=&quot;Latency&quot; /&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# openjdk8 只用`c1`&lt;/span&gt;
java &lt;span class=&quot;nt&quot;&gt;-XX&lt;/span&gt;:TieredStopAtLevel&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1 &lt;span class=&quot;nt&quot;&gt;-jar&lt;/span&gt; app-tester.jar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Time&lt;/th&gt;
      &lt;th&gt;P50&lt;/th&gt;
      &lt;th&gt;P75&lt;/th&gt;
      &lt;th&gt;P90&lt;/th&gt;
      &lt;th&gt;P99&lt;/th&gt;
      &lt;th&gt;P99.9&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0s&lt;/td&gt;
      &lt;td&gt;211.275&lt;/td&gt;
      &lt;td&gt;424.238&lt;/td&gt;
      &lt;td&gt;821.042&lt;/td&gt;
      &lt;td&gt;2786.87&lt;/td&gt;
      &lt;td&gt;3610.91&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;10s&lt;/td&gt;
      &lt;td&gt;96.4706&lt;/td&gt;
      &lt;td&gt;108.599&lt;/td&gt;
      &lt;td&gt;191.273&lt;/td&gt;
      &lt;td&gt;494.333&lt;/td&gt;
      &lt;td&gt;949.333&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;20s&lt;/td&gt;
      &lt;td&gt;10.2844&lt;/td&gt;
      &lt;td&gt;23.4359&lt;/td&gt;
      &lt;td&gt;63.6352&lt;/td&gt;
      &lt;td&gt;86.0784&lt;/td&gt;
      &lt;td&gt;98.6207&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;30s&lt;/td&gt;
      &lt;td&gt;9.46099&lt;/td&gt;
      &lt;td&gt;15.5472&lt;/td&gt;
      &lt;td&gt;45.2062&lt;/td&gt;
      &lt;td&gt;76.5942&lt;/td&gt;
      &lt;td&gt;98.125&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;40s&lt;/td&gt;
      &lt;td&gt;9.55367&lt;/td&gt;
      &lt;td&gt;13.2348&lt;/td&gt;
      &lt;td&gt;57.7083&lt;/td&gt;
      &lt;td&gt;85.3202&lt;/td&gt;
      &lt;td&gt;89.7537&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;50s&lt;/td&gt;
      &lt;td&gt;9.1522&lt;/td&gt;
      &lt;td&gt;12.9049&lt;/td&gt;
      &lt;td&gt;23.0952&lt;/td&gt;
      &lt;td&gt;64.2593&lt;/td&gt;
      &lt;td&gt;82.2222&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;60s&lt;/td&gt;
      &lt;td&gt;9.11557&lt;/td&gt;
      &lt;td&gt;12.6746&lt;/td&gt;
      &lt;td&gt;37.7211&lt;/td&gt;
      &lt;td&gt;65.5556&lt;/td&gt;
      &lt;td&gt;131.25&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;70s&lt;/td&gt;
      &lt;td&gt;9.74239&lt;/td&gt;
      &lt;td&gt;13.1191&lt;/td&gt;
      &lt;td&gt;39.3182&lt;/td&gt;
      &lt;td&gt;87.6531&lt;/td&gt;
      &lt;td&gt;102.553&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;80s&lt;/td&gt;
      &lt;td&gt;8.4283&lt;/td&gt;
      &lt;td&gt;11.9672&lt;/td&gt;
      &lt;td&gt;49.375&lt;/td&gt;
      &lt;td&gt;87.4699&lt;/td&gt;
      &lt;td&gt;99.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;90s&lt;/td&gt;
      &lt;td&gt;10.1996&lt;/td&gt;
      &lt;td&gt;27.13&lt;/td&gt;
      &lt;td&gt;65.2153&lt;/td&gt;
      &lt;td&gt;78.6027&lt;/td&gt;
      &lt;td&gt;85.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;100s&lt;/td&gt;
      &lt;td&gt;9.77195&lt;/td&gt;
      &lt;td&gt;17.5556&lt;/td&gt;
      &lt;td&gt;62.7608&lt;/td&gt;
      &lt;td&gt;77.1237&lt;/td&gt;
      &lt;td&gt;85.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;110s&lt;/td&gt;
      &lt;td&gt;9.28459&lt;/td&gt;
      &lt;td&gt;12.2199&lt;/td&gt;
      &lt;td&gt;15.7638&lt;/td&gt;
      &lt;td&gt;74.0667&lt;/td&gt;
      &lt;td&gt;82.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;120s&lt;/td&gt;
      &lt;td&gt;9.76496&lt;/td&gt;
      &lt;td&gt;14.0235&lt;/td&gt;
      &lt;td&gt;42.4895&lt;/td&gt;
      &lt;td&gt;58.5942&lt;/td&gt;
      &lt;td&gt;140.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;130s&lt;/td&gt;
      &lt;td&gt;9.375&lt;/td&gt;
      &lt;td&gt;13.8936&lt;/td&gt;
      &lt;td&gt;55.1143&lt;/td&gt;
      &lt;td&gt;476.0&lt;/td&gt;
      &lt;td&gt;1273.44&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;140s&lt;/td&gt;
      &lt;td&gt;10.2008&lt;/td&gt;
      &lt;td&gt;20.4795&lt;/td&gt;
      &lt;td&gt;41.8148&lt;/td&gt;
      &lt;td&gt;90.0&lt;/td&gt;
      &lt;td&gt;147.143&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;150s&lt;/td&gt;
      &lt;td&gt;11.3643&lt;/td&gt;
      &lt;td&gt;43.3864&lt;/td&gt;
      &lt;td&gt;73.0446&lt;/td&gt;
      &lt;td&gt;170.252&lt;/td&gt;
      &lt;td&gt;284.783&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;160s&lt;/td&gt;
      &lt;td&gt;11.8096&lt;/td&gt;
      &lt;td&gt;66.9327&lt;/td&gt;
      &lt;td&gt;93.0346&lt;/td&gt;
      &lt;td&gt;281.25&lt;/td&gt;
      &lt;td&gt;616.286&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;170s&lt;/td&gt;
      &lt;td&gt;9.89216&lt;/td&gt;
      &lt;td&gt;16.4603&lt;/td&gt;
      &lt;td&gt;66.4623&lt;/td&gt;
      &lt;td&gt;107.273&lt;/td&gt;
      &lt;td&gt;262.5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;180s&lt;/td&gt;
      &lt;td&gt;10.0154&lt;/td&gt;
      &lt;td&gt;17.9604&lt;/td&gt;
      &lt;td&gt;49.9324&lt;/td&gt;
      &lt;td&gt;78.0159&lt;/td&gt;
      &lt;td&gt;131.429&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;190s&lt;/td&gt;
      &lt;td&gt;9.32549&lt;/td&gt;
      &lt;td&gt;14.1396&lt;/td&gt;
      &lt;td&gt;35.3042&lt;/td&gt;
      &lt;td&gt;84.6721&lt;/td&gt;
      &lt;td&gt;97.8125&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;200s&lt;/td&gt;
      &lt;td&gt;9.43291&lt;/td&gt;
      &lt;td&gt;12.44&lt;/td&gt;
      &lt;td&gt;33.3529&lt;/td&gt;
      &lt;td&gt;58.1505&lt;/td&gt;
      &lt;td&gt;147.661&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020/02/latency-openjdk8-tier-1.png&quot; alt=&quot;Latency&quot; /&gt;&lt;/p&gt;

&lt;p&gt;经过对比，只用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c1&lt;/code&gt;虽然前期稍微好一点，但是后期性能差太多了；直接用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c2&lt;/code&gt;更加剧了前期的问题，虽然预热很快就结束了，但也无法接受。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;尝试-java-13-appcds&quot;&gt;尝试 Java 13 AppCDS&lt;/h4&gt;

&lt;p&gt;Java 从 10 开始提供 AppCDS，可以从这篇文章中了解到更多信息：&lt;a href=&quot;https://blog.codefx.org/java/application-class-data-sharing/&quot;&gt;Improve Launch Times On Java 13 With Application Class-Data Sharing
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本质上是先把程序跑一遍，分析一下哪些 class 需要编译，然后提前编译一下缓存下来。&lt;/p&gt;

&lt;p&gt;所以程序直接跑就不行了，需要提前预处理一下，这里的启动脚本需要改一下：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# openjdk13&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;WARM_UP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1 java &lt;span class=&quot;nt&quot;&gt;-jar&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-XX&lt;/span&gt;:ArchiveClassesAtExit&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;app-cds.jsa app-tester.jar
java &lt;span class=&quot;nt&quot;&gt;-jar&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-XX&lt;/span&gt;:SharedArchiveFile&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;app-cds.jsa app-tester.jar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里对程序也进行了一点改动，会在启动完成后调用一下内部业务让 AppCDS 知道这个类需要被缓存，然后也要加一个环境变量，如果跑一下的目的是分析 class 缓存情况，那么启动完了就可以直接停掉了。&lt;/p&gt;

&lt;p&gt;我这里内部是根据环境变量&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WARM_UP=1&lt;/code&gt;来判断的。也可以不实现这个，直接在启动脚本里固定时间把程序关闭。&lt;/p&gt;

&lt;p&gt;结果如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Time&lt;/th&gt;
      &lt;th&gt;P50&lt;/th&gt;
      &lt;th&gt;P75&lt;/th&gt;
      &lt;th&gt;P90&lt;/th&gt;
      &lt;th&gt;P99&lt;/th&gt;
      &lt;th&gt;P99.9&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0s&lt;/td&gt;
      &lt;td&gt;197.4&lt;/td&gt;
      &lt;td&gt;465.625&lt;/td&gt;
      &lt;td&gt;826.97&lt;/td&gt;
      &lt;td&gt;1886.29&lt;/td&gt;
      &lt;td&gt;2544.86&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;10s&lt;/td&gt;
      &lt;td&gt;182.765&lt;/td&gt;
      &lt;td&gt;238.632&lt;/td&gt;
      &lt;td&gt;446.176&lt;/td&gt;
      &lt;td&gt;995.955&lt;/td&gt;
      &lt;td&gt;1812.9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;20s&lt;/td&gt;
      &lt;td&gt;99.205&lt;/td&gt;
      &lt;td&gt;160.3&lt;/td&gt;
      &lt;td&gt;267.201&lt;/td&gt;
      &lt;td&gt;1503.85&lt;/td&gt;
      &lt;td&gt;2551.17&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;30s&lt;/td&gt;
      &lt;td&gt;95.7119&lt;/td&gt;
      &lt;td&gt;106.129&lt;/td&gt;
      &lt;td&gt;183.418&lt;/td&gt;
      &lt;td&gt;503.273&lt;/td&gt;
      &lt;td&gt;758.72&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;40s&lt;/td&gt;
      &lt;td&gt;54.4359&lt;/td&gt;
      &lt;td&gt;89.8943&lt;/td&gt;
      &lt;td&gt;99.8245&lt;/td&gt;
      &lt;td&gt;193.144&lt;/td&gt;
      &lt;td&gt;246.976&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;50s&lt;/td&gt;
      &lt;td&gt;63.6049&lt;/td&gt;
      &lt;td&gt;94.1969&lt;/td&gt;
      &lt;td&gt;108.253&lt;/td&gt;
      &lt;td&gt;192.8&lt;/td&gt;
      &lt;td&gt;280.769&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;60s&lt;/td&gt;
      &lt;td&gt;55.2794&lt;/td&gt;
      &lt;td&gt;80.7453&lt;/td&gt;
      &lt;td&gt;95.5563&lt;/td&gt;
      &lt;td&gt;238.682&lt;/td&gt;
      &lt;td&gt;414.314&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;70s&lt;/td&gt;
      &lt;td&gt;70.991&lt;/td&gt;
      &lt;td&gt;97.7175&lt;/td&gt;
      &lt;td&gt;134.101&lt;/td&gt;
      &lt;td&gt;558.424&lt;/td&gt;
      &lt;td&gt;1571.53&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;80s&lt;/td&gt;
      &lt;td&gt;53.8337&lt;/td&gt;
      &lt;td&gt;83.1865&lt;/td&gt;
      &lt;td&gt;96.9365&lt;/td&gt;
      &lt;td&gt;175.921&lt;/td&gt;
      &lt;td&gt;276.923&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;90s&lt;/td&gt;
      &lt;td&gt;55.6827&lt;/td&gt;
      &lt;td&gt;83.9577&lt;/td&gt;
      &lt;td&gt;99.0229&lt;/td&gt;
      &lt;td&gt;285.921&lt;/td&gt;
      &lt;td&gt;616.3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;100s&lt;/td&gt;
      &lt;td&gt;68.2399&lt;/td&gt;
      &lt;td&gt;91.0623&lt;/td&gt;
      &lt;td&gt;99.4049&lt;/td&gt;
      &lt;td&gt;450.0&lt;/td&gt;
      &lt;td&gt;1210.88&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;110s&lt;/td&gt;
      &lt;td&gt;9.45747&lt;/td&gt;
      &lt;td&gt;22.6015&lt;/td&gt;
      &lt;td&gt;38.6823&lt;/td&gt;
      &lt;td&gt;89.0323&lt;/td&gt;
      &lt;td&gt;134.074&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;120s&lt;/td&gt;
      &lt;td&gt;6.56564&lt;/td&gt;
      &lt;td&gt;9.21653&lt;/td&gt;
      &lt;td&gt;11.3129&lt;/td&gt;
      &lt;td&gt;17.7818&lt;/td&gt;
      &lt;td&gt;51.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;130s&lt;/td&gt;
      &lt;td&gt;6.38191&lt;/td&gt;
      &lt;td&gt;8.77066&lt;/td&gt;
      &lt;td&gt;11.1053&lt;/td&gt;
      &lt;td&gt;16.1176&lt;/td&gt;
      &lt;td&gt;20.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;140s&lt;/td&gt;
      &lt;td&gt;6.35324&lt;/td&gt;
      &lt;td&gt;8.74876&lt;/td&gt;
      &lt;td&gt;10.9444&lt;/td&gt;
      &lt;td&gt;15.0841&lt;/td&gt;
      &lt;td&gt;19.9286&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;150s&lt;/td&gt;
      &lt;td&gt;5.90095&lt;/td&gt;
      &lt;td&gt;8.38842&lt;/td&gt;
      &lt;td&gt;10.4839&lt;/td&gt;
      &lt;td&gt;101.412&lt;/td&gt;
      &lt;td&gt;230.556&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;160s&lt;/td&gt;
      &lt;td&gt;6.2864&lt;/td&gt;
      &lt;td&gt;8.5492&lt;/td&gt;
      &lt;td&gt;10.8375&lt;/td&gt;
      &lt;td&gt;17.7391&lt;/td&gt;
      &lt;td&gt;23.3668&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;170s&lt;/td&gt;
      &lt;td&gt;6.47078&lt;/td&gt;
      &lt;td&gt;8.4787&lt;/td&gt;
      &lt;td&gt;10.6983&lt;/td&gt;
      &lt;td&gt;13.8976&lt;/td&gt;
      &lt;td&gt;16.7143&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;180s&lt;/td&gt;
      &lt;td&gt;6.18094&lt;/td&gt;
      &lt;td&gt;8.41088&lt;/td&gt;
      &lt;td&gt;10.6717&lt;/td&gt;
      &lt;td&gt;16.2474&lt;/td&gt;
      &lt;td&gt;19.1111&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;190s&lt;/td&gt;
      &lt;td&gt;6.40341&lt;/td&gt;
      &lt;td&gt;8.61996&lt;/td&gt;
      &lt;td&gt;10.7623&lt;/td&gt;
      &lt;td&gt;14.9554&lt;/td&gt;
      &lt;td&gt;16.7245&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;200s&lt;/td&gt;
      &lt;td&gt;5.82933&lt;/td&gt;
      &lt;td&gt;8.4235&lt;/td&gt;
      &lt;td&gt;11.1083&lt;/td&gt;
      &lt;td&gt;17.7143&lt;/td&gt;
      &lt;td&gt;20.0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020/02/latency-openjdk13-appcds.png&quot; alt=&quot;Latency&quot; /&gt;&lt;/p&gt;

&lt;p&gt;好像效果并不是非常明显，这也正常，因为我的预热代码是不可能覆盖所有真正要跑的代码的。&lt;/p&gt;

&lt;p&gt;能否让程序在长时间运行的时候顺便把这些信息缓存下来，然后在下一次启动的时候直接用呢？因为这种模式下缓存下来的才是真正有用的。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;尝试-openj9&quot;&gt;尝试 OpenJ9&lt;/h4&gt;

&lt;p&gt;后来又发现 OpenJ9 在这块做得非常强大，细节可以看这两篇文章：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/java/j-optimize-jvm-startup-with-eclipse-openjj9/index.html&quot;&gt;使用 Eclipse OpenJ9 优化 JVM 启动&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/java/j-class-sharing-openj9/index.html&quot;&gt;Eclipse OpenJ9 中的类共享&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;OpenJ9 配置起来非常简单，而且它可以做到所有 JVM 程序共享同一份缓存，缓存满了以后它能自动清理长时间不用的 class。&lt;/p&gt;

&lt;p&gt;除此以外，它还可以大幅减少 JVM 内存占用。因为一个简单的 Java 程序跑起来后大部内存都是公用框架占用的。&lt;/p&gt;

&lt;p&gt;在 Kubernetes 里想要用到这个的话，需要把这个共享文件挂在到宿主机上，否则放在容器内的话一启动就丢失了，也就没有意义了。&lt;/p&gt;

&lt;p&gt;我这里会压测两次，第一次是预热，让它生成缓存。第二次是真正的压测，直接贴上第二次压测的结果：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# openjdk8-openj9&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 打印一下统计信息，确认缓存有效&lt;/span&gt;
java &lt;span class=&quot;nt&quot;&gt;-Xshareclasses&lt;/span&gt;:cacheDir&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/tmp/java/cache,printStats &lt;span class=&quot;nt&quot;&gt;-Xscmx256M&lt;/span&gt;

java &lt;span class=&quot;nt&quot;&gt;-jar&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Xshareclasses&lt;/span&gt;:cacheDir&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/tmp/java/cache &lt;span class=&quot;nt&quot;&gt;-Xscmx256M&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Xtune&lt;/span&gt;:virtualized app-tester.jar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;打印出的缓存信息说明缓存的确有效：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Current statistics for cache &quot;sharedcc_root&quot;:

Cache created with:
	-Xnolinenumbers                      = false
	BCI Enabled                          = true
	Restrict Classpaths                  = false
	Feature                              = cr

Cache contains only classes with line numbers

base address                         = 0x00007FCEE4059000
end address                          = 0x00007FCEF4000000
allocation pointer                   = 0x00007FCEE4ECE618

cache size                           = 268434848
softmx bytes                         = 268434848
free bytes                           = 214523260
ROMClass bytes                       = 15160856
AOT bytes                            = 14677324
Reserved space for AOT bytes         = -1
Maximum space for AOT bytes          = -1
JIT data bytes                       = 198972
Reserved space for JIT data bytes    = -1
Maximum space for JIT data bytes     = -1
Zip cache bytes                      = 921504
Startup hint bytes                   = 0
Data bytes                           = 363936
Metadata bytes                       = 1146436
Metadata % used                      = 2%
Class debug area size                = 21442560
Class debug area used bytes          = 2226388
Class debug area % used              = 10%

# ROMClasses                         = 19693
# AOT Methods                        = 3852
# Classpaths                         = 31
# URLs                               = 0
# Tokens                             = 0
# Zip caches                         = 5
# Startup hints                      = 0
# Stale classes                      = 13522
% Stale classes                      = 68%

Cache is 20% full

Cache is accessible to current user = true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Time&lt;/th&gt;
      &lt;th&gt;P50&lt;/th&gt;
      &lt;th&gt;P75&lt;/th&gt;
      &lt;th&gt;P90&lt;/th&gt;
      &lt;th&gt;P99&lt;/th&gt;
      &lt;th&gt;P99.9&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0s&lt;/td&gt;
      &lt;td&gt;102.454&lt;/td&gt;
      &lt;td&gt;188.202&lt;/td&gt;
      &lt;td&gt;278.445&lt;/td&gt;
      &lt;td&gt;2341.51&lt;/td&gt;
      &lt;td&gt;2727.5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;10s&lt;/td&gt;
      &lt;td&gt;67.1237&lt;/td&gt;
      &lt;td&gt;93.6605&lt;/td&gt;
      &lt;td&gt;111.917&lt;/td&gt;
      &lt;td&gt;288.161&lt;/td&gt;
      &lt;td&gt;500.546&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;20s&lt;/td&gt;
      &lt;td&gt;47.2991&lt;/td&gt;
      &lt;td&gt;75.4605&lt;/td&gt;
      &lt;td&gt;89.9772&lt;/td&gt;
      &lt;td&gt;161.132&lt;/td&gt;
      &lt;td&gt;293.333&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;30s&lt;/td&gt;
      &lt;td&gt;62.2794&lt;/td&gt;
      &lt;td&gt;85.4817&lt;/td&gt;
      &lt;td&gt;96.9474&lt;/td&gt;
      &lt;td&gt;229.545&lt;/td&gt;
      &lt;td&gt;416.667&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;40s&lt;/td&gt;
      &lt;td&gt;49.8906&lt;/td&gt;
      &lt;td&gt;76.3703&lt;/td&gt;
      &lt;td&gt;91.7203&lt;/td&gt;
      &lt;td&gt;150.732&lt;/td&gt;
      &lt;td&gt;236.957&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;50s&lt;/td&gt;
      &lt;td&gt;8.15622&lt;/td&gt;
      &lt;td&gt;11.1215&lt;/td&gt;
      &lt;td&gt;35.0&lt;/td&gt;
      &lt;td&gt;138.242&lt;/td&gt;
      &lt;td&gt;264.286&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;60s&lt;/td&gt;
      &lt;td&gt;43.4973&lt;/td&gt;
      &lt;td&gt;70.217&lt;/td&gt;
      &lt;td&gt;85.4565&lt;/td&gt;
      &lt;td&gt;155.224&lt;/td&gt;
      &lt;td&gt;198.667&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;70s&lt;/td&gt;
      &lt;td&gt;49.7949&lt;/td&gt;
      &lt;td&gt;75.8014&lt;/td&gt;
      &lt;td&gt;90.5059&lt;/td&gt;
      &lt;td&gt;152.414&lt;/td&gt;
      &lt;td&gt;228.125&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;80s&lt;/td&gt;
      &lt;td&gt;9.25926&lt;/td&gt;
      &lt;td&gt;18.4314&lt;/td&gt;
      &lt;td&gt;87.8878&lt;/td&gt;
      &lt;td&gt;400.0&lt;/td&gt;
      &lt;td&gt;912.47&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;90s&lt;/td&gt;
      &lt;td&gt;7.81955&lt;/td&gt;
      &lt;td&gt;10.5167&lt;/td&gt;
      &lt;td&gt;13.0704&lt;/td&gt;
      &lt;td&gt;61.2437&lt;/td&gt;
      &lt;td&gt;67.8283&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;100s&lt;/td&gt;
      &lt;td&gt;7.43318&lt;/td&gt;
      &lt;td&gt;10.1478&lt;/td&gt;
      &lt;td&gt;12.7896&lt;/td&gt;
      &lt;td&gt;16.963&lt;/td&gt;
      &lt;td&gt;84.6154&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;110s&lt;/td&gt;
      &lt;td&gt;7.2323&lt;/td&gt;
      &lt;td&gt;9.6565&lt;/td&gt;
      &lt;td&gt;12.1038&lt;/td&gt;
      &lt;td&gt;68.6&lt;/td&gt;
      &lt;td&gt;111.232&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;120s&lt;/td&gt;
      &lt;td&gt;7.27096&lt;/td&gt;
      &lt;td&gt;9.58172&lt;/td&gt;
      &lt;td&gt;11.3835&lt;/td&gt;
      &lt;td&gt;58.5185&lt;/td&gt;
      &lt;td&gt;69.8592&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;130s&lt;/td&gt;
      &lt;td&gt;7.87992&lt;/td&gt;
      &lt;td&gt;9.91841&lt;/td&gt;
      &lt;td&gt;11.604&lt;/td&gt;
      &lt;td&gt;14.7463&lt;/td&gt;
      &lt;td&gt;42.5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;140s&lt;/td&gt;
      &lt;td&gt;7.87443&lt;/td&gt;
      &lt;td&gt;10.1154&lt;/td&gt;
      &lt;td&gt;12.9932&lt;/td&gt;
      &lt;td&gt;69.172&lt;/td&gt;
      &lt;td&gt;87.0416&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;150s&lt;/td&gt;
      &lt;td&gt;7.90534&lt;/td&gt;
      &lt;td&gt;10.4325&lt;/td&gt;
      &lt;td&gt;12.4497&lt;/td&gt;
      &lt;td&gt;24.0323&lt;/td&gt;
      &lt;td&gt;79.011&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;160s&lt;/td&gt;
      &lt;td&gt;7.36498&lt;/td&gt;
      &lt;td&gt;9.81537&lt;/td&gt;
      &lt;td&gt;12.6328&lt;/td&gt;
      &lt;td&gt;65.4645&lt;/td&gt;
      &lt;td&gt;70.6221&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;170s&lt;/td&gt;
      &lt;td&gt;7.34259&lt;/td&gt;
      &lt;td&gt;9.52754&lt;/td&gt;
      &lt;td&gt;11.1351&lt;/td&gt;
      &lt;td&gt;14.6988&lt;/td&gt;
      &lt;td&gt;41.7267&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;180s&lt;/td&gt;
      &lt;td&gt;7.41449&lt;/td&gt;
      &lt;td&gt;10.0634&lt;/td&gt;
      &lt;td&gt;12.3634&lt;/td&gt;
      &lt;td&gt;46.358&lt;/td&gt;
      &lt;td&gt;51.5424&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;190s&lt;/td&gt;
      &lt;td&gt;7.35043&lt;/td&gt;
      &lt;td&gt;9.78647&lt;/td&gt;
      &lt;td&gt;12.1596&lt;/td&gt;
      &lt;td&gt;19.8182&lt;/td&gt;
      &lt;td&gt;40.7143&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;200s&lt;/td&gt;
      &lt;td&gt;7.80748&lt;/td&gt;
      &lt;td&gt;9.80591&lt;/td&gt;
      &lt;td&gt;11.1057&lt;/td&gt;
      &lt;td&gt;15.5394&lt;/td&gt;
      &lt;td&gt;17.7627&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020/02/latency-openjdk8-openj9.png&quot; alt=&quot;Latency&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个效果可以说是非常惊喜了，P99 和 P99.9 虽然前 10 秒高了一点，但是后面立刻降了下来，而 P90 简直是吊打别的方案。&lt;/p&gt;

&lt;p&gt;当然，根据文档看这个是会影响吞吐量的，也就是说同样的 QPS 消耗的 CPU 会高一点，可以看到 P50 也稍微高了一点。&lt;/p&gt;

&lt;p&gt;最后再把六个方案的 P90 放在一起看一下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020/02/latency-p90.png&quot; alt=&quot;Latency&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所以如何选择就要看你的取舍了，如果你的业务真的对冷启动很敏感，可以接受吞吐下降，那么 OpenJ9 是个很好的选择。&lt;/p&gt;

&lt;p&gt;OpenJ9 除了启动预热速度快以外，内存消耗也非常小。一般一个 Spring Boot 的程序启动就要至少 200M 以上内存，最简单的程序都要分配个 512M。而用了 OpenJ9 后 class 都被做成了内存映射文件，所以工作内存占用会非常小，对于简单程序非常有优势。&lt;/p&gt;

&lt;p&gt;除了从 JVM 角度优化，能不能从发布过程角度优化呢？&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;改变发布过程&quot;&gt;改变发布过程&lt;/h4&gt;

&lt;p&gt;既然传统微服务可以控制发布过程，那 Kubernetes 集群内从技术角度肯定也是可以实现的。&lt;/p&gt;

&lt;p&gt;Kubernetes 本身没有这个能力，但是通过 Istio 其实是可以是实现的。&lt;/p&gt;

&lt;p&gt;我们找到了这个开源项目：&lt;a href=&quot;https://docs.flagger.app/&quot;&gt;Flagger&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;它就是利用 Istio 的流量控制来精准地分配流量比例：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020/02/flagger-canary-steps.png&quot; alt=&quot;Flagger&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们也在线上实测过，但实际效果上还有一点点偏差。因为它本质上不是为了解决我们这个问题而做的，它本身是为了做金丝雀发布或者蓝绿发布的。&lt;/p&gt;

&lt;p&gt;但我们下一步可能会考虑利用这个开源项目改造出适应我们自己的方案。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;上面提的几个问题和很多方案，我们都在线上试验过，上面的测试结果也都是我严格控制环境测出来的。&lt;/p&gt;

&lt;p&gt;针对三种情况，目前都有可以改善的不完美解决办法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Golang + Istio 启动失败：让业务容器比 Envoy 晚启动几秒&lt;/li&gt;
  &lt;li&gt;Istio 优雅关闭：配置 Istio 安装参数，让 Envoy 比业务容器晚关闭几秒&lt;/li&gt;
  &lt;li&gt;Java 程序启动时负载过高延迟过大：用 OpenJ9 或者自研发布控制工具&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;还好这个问题不算一个特别大的问题，只是作为一个工程师想尽量让启动和关闭的场景下可以 0 报错。&lt;/p&gt;

&lt;p&gt;后面我们还会继续探索，想办法解决这些问题。&lt;/p&gt;
</description>
				<pubDate>Fri, 28 Feb 2020 00:00:00 +0000</pubDate>
				<link>/2020/02/graceful-start-and-shutdown.html</link>
				<guid isPermaLink="true">/2020/02/graceful-start-and-shutdown.html</guid>
			</item>
		
			<item>
				<title>Service Mesh 实践（四）：从开源 Ingress 到自研 API Gateway</title>
				<description>&lt;h3 id=&quot;kubernetes-ingress&quot;&gt;Kubernetes Ingress&lt;/h3&gt;

&lt;p&gt;Ingress 的相关概念可以直接看 Kubernetes 的文档，讲的很清楚了：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://kubernetes.io/docs/concepts/services-networking/ingress/&quot;&gt;Ingress&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/&quot;&gt;Ingress Controllers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;简单的来说，它和传统服务器架构中的负载均衡器是类似的，本质上就是把集群内部的服务暴露给集群外。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    internet
        |
   [ Ingress ]
   --|-----|--
   [ Services ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这块技术方案非常多，要开发一个自己的 Kubernetes Ingress 也不难。看 Ingress Controllers 这篇文章，Ingress Controllers 的意思就是 Kubernetes Ingress 的具体实现。&lt;/p&gt;

&lt;p&gt;两年前比较靠谱的方案主要是 Nginx Ingress 和 Istio Gateway，而现在技术方案已经非常多了。所有传统负载均衡厂商基本都为 Kubernetes 开发了 Ingress。&lt;/p&gt;

&lt;p&gt;从严格的定义看，Istio Gateway 不能算是一个 Ingress Controller，因为它并不是根据 Kubernetes 里的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ingress&lt;/code&gt;资源来定义路由规则的。&lt;/p&gt;

&lt;p&gt;Kubernetes Ingress 的理念是想做一层抽象，配置和实现解耦，所有的配置都是配置&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ingress&lt;/code&gt;，而不需要关心具体的技术实现。&lt;/p&gt;

&lt;p&gt;Istio Gateway 不用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ingress&lt;/code&gt;来配置，而是使用了自己的一套资源来配置，实际的功能上也比 Kubernetes Ingress 更丰富。因为技术实现脱离了 Kubernetes Ingress，所以我觉得严格的定义来看它不是一个 Ingress Controller。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;istio-gateway&quot;&gt;Istio Gateway&lt;/h3&gt;

&lt;p&gt;既然我们用 Istio 做集群内的服务治理，那么用 Istio Gateway 也是合情合理的事情。因为 Istio Gateway 的相关配置和集群内整合了 Istio 的服务相关配置都是相同的，只需要配置一份就可以通用。而且功能上也比 Kubernetes Ingress 丰富的多。&lt;/p&gt;

&lt;p&gt;我们一开始也不是没有用过，最早我们就是用的 Istio Gateway。&lt;/p&gt;

&lt;p&gt;但是它有什么问题呢？&lt;/p&gt;

&lt;p&gt;很早版本的 Istio 和 Helm 配合使用时有很多问题的，经常遇到升级版本出问题导致整个 Istio 只能卸载重来的情况。Istio 也一直在努力改善这个问题，例如现在版本把 CRDs 和 Helm Chart 分离；还有开发中的 Istio Operator 完全脱离 Helm。这些都是为了摆脱 Helm 带来的问题，毕竟部署 Istio 还是有点复杂的，模块太多。&lt;/p&gt;

&lt;p&gt;另外从 Istio 的设计理念角度看，整个集群就算没有 Istio 也可以正常运作的，无非就是缺失一些辅助功能。遇到上述问题的时候，我们只能把 Istio 卸载重装，而在这个过程中，最大的问题就是 Istio Gateway 了。&lt;/p&gt;

&lt;p&gt;用了 Istio Gateway 后，对 Istio 就有了强依赖，Istio Gateway 又是打包在 Istio 中的，无法独立管理。&lt;/p&gt;

&lt;p&gt;最后考虑到未来我们一定是脱离这些搞自研的，所以决定摆脱 Istio Gateway 的限制，也不要让我们的集群对 Istio 产生太强的依赖。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;nginx-ingress&quot;&gt;Nginx Ingress&lt;/h3&gt;

&lt;p&gt;排除 Istio Gateway 后，开始尝试使用 Nginx Ingress，但是也遇到了一些问题。这里可以贴一些问题的排查思路和解决方案，结果不是最重要的，最重要的是解决问题的思路。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020/02/nginx-ingress-with-istio.png&quot; alt=&quot;Nginx Ingress with Istio&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一开始我们搭建 Nginx Ingress 的时候是包着 Istio 的，因为如果不包着 Istio，Nginx Ingress 访问集群内部服务的时候就无法用到 Istio 相关功能了。&lt;/p&gt;

&lt;p&gt;Envoy + Pilot 的配合其实是替代了 Kubernetes 内置的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Service&lt;/code&gt;，做了一套自己的服务发现机制，因为这样才能实现更强大的流量控制功能。例如 A 服务访问 B 服务，B 服务中有一台主机会偶发性报 500，但它的 Kubernetes 健康检查却是正常的，没有完全挂掉。如果配置了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DestinationRule&lt;/code&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;outlierDetection&lt;/code&gt;后，Envoy 会自动拆除目标机器。&lt;/p&gt;

&lt;p&gt;和所有的流量控制一样，这套逻辑是在调用方来实现，而不是服务提供方实现的。按照这张图的例子，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user-service&lt;/code&gt;的信息会由 Pilot 通过 xDS 协议推送给 Envoy，Envoy 就知道如果要访问&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user-service&lt;/code&gt;的时候要访问哪些 IP 了。启用 Istio 后&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user-service&lt;/code&gt;里面的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Service&lt;/code&gt;并没有实际的作用了，只是用来给 Pilot 分析这个服务对应着哪些&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt;而已。实际的流量也不会像 Kubernetes 里的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Service&lt;/code&gt;一样通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;iptables&lt;/code&gt;规则 NAT 转发到对应的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt;了。&lt;/p&gt;

&lt;p&gt;我们这里来简单的搭建一个环境，方便后续演示。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;本地跑-kubernetes-技巧&quot;&gt;本地跑 Kubernetes 技巧&lt;/h4&gt;

&lt;p&gt;我们先来改一个配置：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;ifconfig lo0 &lt;span class=&quot;nb&quot;&gt;alias &lt;/span&gt;100.64.0.0 255.255.255.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里有一个小技巧，国内在本机跑 Kubernetes 集群一直要面临翻墙问题。&lt;/p&gt;

&lt;p&gt;虽然可以跑 SS，然后配置代理，但是 macOS 上的 Docker 都是基于虚拟机来实现的。&lt;/p&gt;

&lt;p&gt;用虚拟机实现有什么问题呢，你的 SS HTTP Proxy 一般都是监听&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;127.0.0.1:1087&lt;/code&gt;的。&lt;/p&gt;

&lt;p&gt;如果你直接配置这个地址的话虚拟机内的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;127.0.0.1&lt;/code&gt;是虚拟机的本地回环地址，并不是你宿主机，所以无法直接访问。&lt;/p&gt;

&lt;p&gt;解决办法也很简答，让 SS HTTP Proxy 监听&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0.0.0.0:1087&lt;/code&gt;，然后把你的局域网内网 IP 配置到 Docker 代理中就行了。&lt;/p&gt;

&lt;p&gt;但你在公司，家庭来回切换的时候，内网 IP 是一直会变的，所以可以通过这个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alias&lt;/code&gt;给你的网卡加一个别名，然后配置到 Docker 代理中就行了。一般配置一个不冲突的局域网 IP 就行了。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;环境搭建&quot;&gt;环境搭建&lt;/h4&gt;

&lt;p&gt;言归正传我们来搭建一下环境：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Create Istio namespace&lt;/span&gt;
kubectl create namespace istio-system

&lt;span class=&quot;c&quot;&gt;# Install Istio&lt;/span&gt;
helm repo add istio.io https://storage.googleapis.com/istio-release/releases/1.4.5/charts/ &lt;span class=&quot;c&quot;&gt;# Install Istio helm repo&lt;/span&gt;
helm upgrade &lt;span class=&quot;nt&quot;&gt;--install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--force&lt;/span&gt; istio-init istio.io/istio-init &lt;span class=&quot;nt&quot;&gt;--namespace&lt;/span&gt; istio-system &lt;span class=&quot;c&quot;&gt;# Install Istio CRDs&lt;/span&gt;
kubectl &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; istio-system &lt;span class=&quot;nb&quot;&gt;wait&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;condition&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;complete &lt;/span&gt;job &lt;span class=&quot;nt&quot;&gt;--all&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# Waiting for Istio CRDs job done&lt;/span&gt;
helm upgrade istio &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; istio.io/istio &lt;span class=&quot;nt&quot;&gt;--namespace&lt;/span&gt; istio-system &lt;span class=&quot;nt&quot;&gt;--set&lt;/span&gt; gateways.enabled&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;false&quot;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# Install Istio&lt;/span&gt;
kubectl label namespace default istio-injection&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;enabled &lt;span class=&quot;c&quot;&gt;# Enable Istio auto inject&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# Install Nginx Ingress&lt;/span&gt;
helm upgrade &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; nginx-ingress stable/nginx-ingress
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;创建服务&quot;&gt;创建服务&lt;/h4&gt;

&lt;p&gt;安装一个测试用的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user-service&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;apps/v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Deployment&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;user-service&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;matchLabels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;user-service&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;replicas&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;user-service&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;containers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx:latest&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;containerPort&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;80&lt;/span&gt;
&lt;span class=&quot;nn&quot;&gt;---&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Service&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;user-service&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;user-service&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;80&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;protocol&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;TCP&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;user-service&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;配置-ingress&quot;&gt;配置 Ingress&lt;/h4&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;networking.k8s.io/v1beta1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Ingress&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;annotations&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;kubernetes.io/ingress.class&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;user-service&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;user-service.dozer.cc&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;paths&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;backend&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
              &lt;span class=&quot;na&quot;&gt;serviceName&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;user-service&lt;/span&gt;
              &lt;span class=&quot;na&quot;&gt;servicePort&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;80&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;一览&quot;&gt;一览&lt;/h4&gt;

&lt;p&gt;目前集群内&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;default&lt;/code&gt;命名空间下有这些东西：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NAME                                                 READY   STATUS    RESTARTS   AGE
pod/nginx-ingress-controller-6f65cf7dcd-tjt9g        2/2     Running   0          16m
pod/nginx-ingress-default-backend-576b86996d-8b66l   2/2     Running   0          16m
pod/user-service-8dc746bfb-jvcn4                     2/2     Running   0          5m13s

NAME                                    TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)                      AGE
service/kubernetes                      ClusterIP      10.96.0.1       &amp;lt;none&amp;gt;        443/TCP                      3h2m
service/nginx-ingress-controller        LoadBalancer   10.97.233.209   localhost     80:32095/TCP,443:30051/TCP   20m
service/nginx-ingress-default-backend   ClusterIP      10.104.45.225   &amp;lt;none&amp;gt;        80/TCP                       20m
service/user-service                    ClusterIP      10.100.97.73    &amp;lt;none&amp;gt;        80/TCP                       5m13s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;访问-nginx-ingress&quot;&gt;访问 Nginx Ingress&lt;/h4&gt;

&lt;p&gt;因为这是本地的 Kubernetes 集群，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;service/nginx-ingress-controller&lt;/code&gt; 虽然类型是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LoadBalancer&lt;/code&gt;，但实际上还是访问不到的。&lt;/p&gt;

&lt;p&gt;所以只能用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;port-forward&lt;/code&gt;来访问 Nginx Ingress 了。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl port-forward service/nginx-ingress-controller 8080:80 &amp;amp;

curl localhost:8080 &lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; Host:user-service.dozer.cc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;检查结果&quot;&gt;检查结果&lt;/h4&gt;

&lt;p&gt;Nginx 是根据&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Host&lt;/code&gt;来把流量分发到对应的服务的，所以要在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;curl&lt;/code&gt;里传一下&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Host&lt;/code&gt;。然后看一下&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user-service&lt;/code&gt;的 Access Log，就可以看到访问日志了：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl logs &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;user-service &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; nginx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1 - - [25/Feb/2020:11:56:51 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.64.1&quot; &quot;127.0.0.1&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;nginx-ingress-出口流量问题&quot;&gt;Nginx Ingress 出口流量问题&lt;/h3&gt;

&lt;p&gt;环境搭建好了，访问也通了，本来以为一切很完美，但是当我们用上 Istio &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VirtualService&lt;/code&gt; 的时候就出问题了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020/02/nginx-ingress-with-virtualservice.png&quot; alt=&quot;Nginx Ingress with VirtualService&quot; /&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;再创建一个服务&quot;&gt;再创建一个服务&lt;/h4&gt;

&lt;p&gt;我们再创建一个服务&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user-service-canary&lt;/code&gt;做灰度发布：&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;apps/v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Deployment&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;user-service-canary&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;matchLabels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;user-service-canary&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;replicas&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;user-service-canary&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;containers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx:latest&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;containerPort&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;80&lt;/span&gt;
&lt;span class=&quot;nn&quot;&gt;---&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Service&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;user-service-canary&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;user-service-canary&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;80&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;protocol&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;TCP&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;user-service-canary&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;配置virtualservice&quot;&gt;配置&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VirtualService&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;然后配置一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VirtualService&lt;/code&gt;把 50% 的流量切到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user-service-canary&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;networking.istio.io/v1alpha3&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;VirtualService&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;user-service&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;hosts&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;user-service&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;route&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;destination&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;user-service&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;weight&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;50&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;destination&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;user-service-canary&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;weight&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;50&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VirtualService&lt;/code&gt;的本质就是转换成了 Envoy 的配置，告诉 Envoy 按照特定的规则分配流量，并不会产生什么新的东西。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;无法命中user-service-canary&quot;&gt;无法命中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user-service-canary&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;然而，再以&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;curl&lt;/code&gt;访问的时候，却发现永远无法命中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user-service-canary&lt;/code&gt;，难道是 Istio 的问题？&lt;/p&gt;

&lt;p&gt;尝试直接启动一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt;然后在内部 debug 一下。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl run debug &lt;span class=&quot;nt&quot;&gt;--generator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;run-pod/v1 &lt;span class=&quot;nt&quot;&gt;--rm&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--image&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;curlimages/curl:latest &lt;span class=&quot;nt&quot;&gt;-it&lt;/span&gt; sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结果发现一切正常，可以命中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user-service-canary&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;后来看了一下 Nginx Ingress Access Log，发现了一些奇怪的现象：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1 - - [25/Feb/2020:12:16:59 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.64.1&quot; 84 0.001 [default-user-service-80] [] 10.1.0.37:80 612 0.001 200 56c050d5862b25d5f172b4ed202f407d
127.0.0.1 - - [25/Feb/2020:12:16:59 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.64.1&quot; 84 0.002 [default-user-service-80] [] 10.1.0.37:80 612 0.002 200 3a8a4a2091b5abd02ca6c196bfbb8673
127.0.0.1 - - [25/Feb/2020:12:16:59 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.64.1&quot; 84 0.002 [default-user-service-80] [] 10.1.0.37:80 612 0.002 200 92433895e58897905011817b55822d4d
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10.1.0.37:80&lt;/code&gt;竟然是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user-service&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt; 的 IP，但是按照我的理解，Nginx 不应该访问&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user-service&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Service&lt;/code&gt; 的 IP 吗？如果没有 Istio，底层是 NAT 转发到对应的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt;的。&lt;/p&gt;

&lt;p&gt;Access Log 里显示的应该是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt; IP。后来搜索后找到了答案，原来 Nginx Ingress 默认会和 Istio 类似，去找到对应&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Service&lt;/code&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt; IP，然后直接访问&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt; IP。&lt;/p&gt;

&lt;p&gt;这个默认行为其实和普通的 Nginx 类似，普通的 Nginx 在配置反向代理的时候，DNS 解析到下游 IP 后就会把这个 IP 缓存，后面并不会更新它。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;修改-nginx-ingress-默认行为&quot;&gt;修改 Nginx Ingress 默认行为&lt;/h4&gt;

&lt;p&gt;后来一番搜索后通过这个 &lt;a href=&quot;https://github.com/kubernetes/ingress-nginx/issues/3171&quot;&gt;Issue&lt;/a&gt; 找到了对应的解决办法：&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;networking.k8s.io/v1beta1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Ingress&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;annotations&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;kubernetes.io/ingress.class&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;nginx.ingress.kubernetes.io/service-upstream&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;true&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;nginx.ingress.kubernetes.io/upstream-vhost&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;user-service.default.svc.cluster.local&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;user-service&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;user-service.dozer.cc&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;paths&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;backend&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
              &lt;span class=&quot;na&quot;&gt;serviceName&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;user-service&lt;/span&gt;
              &lt;span class=&quot;na&quot;&gt;servicePort&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;80&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这两行新的配置的意思就是让 Nginx Ingress 用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Service&lt;/code&gt;的 IP，另外作为一个反向代理一般都会把&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Host&lt;/code&gt;透传，所以这里也要强制把&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Host&lt;/code&gt;改掉，否则 Envoy 不认识这个域名。&lt;/p&gt;

&lt;p&gt;这个问题就通过这种手段解决了。&lt;/p&gt;

&lt;p&gt;另外 Envoy 究竟是根据什么来做路由的呢？一般反向代理都是根据域名的，那哪些域名会被 Envoy 路由到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user-service&lt;/code&gt;呢？&lt;/p&gt;

&lt;p&gt;Istio 已经提供了一些 debug 工具可以让我们看到 Envoy 最终的配置。这个对后续的各种 Istio 配置检查很有帮助，因为当有些 Istio 配置无法理解的时候，可以看看它在 Envoy 那边是什么样的。然后再去查看 Envoy 的文档，会清晰很多。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;istioctl dashboard envoy &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;pod-name&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;运行这行命令后会在浏览器打开一个窗口，可以看到很多 Envoy 的信息，其中 config_dump	就可以看到 Envoy 配置的细节：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020/02/envoy-config.png&quot; alt=&quot;Envoy Config&quot; /&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;nginx-ingress-入口流量问题&quot;&gt;Nginx Ingress 入口流量问题&lt;/h3&gt;

&lt;p&gt;另外一个问题也很棘手，我们看监控的时候总是发现 Nginx Ingress 运行的时候&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt; 流量非常不均衡。很明显是启动早的流量多，启动晚的流量少。&lt;/p&gt;

&lt;p&gt;这种现象在做负载均衡的时候很常见，一般是 HTTP Keep Alive 机制导致的。&lt;/p&gt;

&lt;p&gt;我们的集群并不是直接暴露在公网的，公网流量是经过 AWS Load Balancer 进来的。暴露在公网的负载均衡器一定要足够稳定，否则一旦出现故障虽然可以通过 DNS 切换做故障转移，但是总是需要一点时间的。所以直接把集群内的机器暴露在公网是不合适的，集群内的机器稳定性远不如 AWS Load Balancer。另外从安全的角度，直接把集群暴露在公网也是非常危险的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020/02/alb-ingress-service.png&quot; alt=&quot;ALB with Ingress and Service&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图是我们集群南北流量的路径，这个问题很明显，肯定是 AWS Load Balancer 和 Nginx Ingress 之间保持着一个长连接并且长时间不关闭。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;抓包验证问题&quot;&gt;抓包验证问题&lt;/h4&gt;

&lt;p&gt;为了验证这个问题，想要抓包看看&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYN&lt;/code&gt;包的数量是不是正常。&lt;/p&gt;

&lt;p&gt;Kubernetes 里抓包不是一个简单的事情，想要真多某一个容器抓包的话还要登陆宿主机。这里有对应的教程：&lt;a href=&quot;https://cloud.tencent.com/developer/article/1429330&quot;&gt;Kubernetes 问题定位技巧：容器内抓包
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当然，现在已经不用这么麻烦了，已经有了一些更便捷的工具：&lt;a href=&quot;https://github.com/eldadru/ksniff&quot;&gt;https://github.com/eldadru/ksniff&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;抓包后，线上&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYN&lt;/code&gt;包的确非常少，和 QPS 比起来少得多，完全不是一个正常的比例。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;尝试从-aws-load-balancer-这端解决问题&quot;&gt;尝试从 AWS Load Balancer 这端解决问题&lt;/h4&gt;

&lt;p&gt;发现了问题解决起来也不难，AWS Load Balancer 和 Nginx Ingress 都是反向代理，一般反向代理都可以配置。&lt;/p&gt;

&lt;p&gt;先是去 AWS Load Balancer 这边找，结果没有结果，提了 ticket 后确认 AWS Load Balancer 没有提供这个功能。AWS Load Balancer 可以保证流量是均衡的，但是不会主动断开连接。&lt;/p&gt;

&lt;p&gt;AWS Load Balancer 虽然没有 Keep Alive 最大请求数这个功能，但是它会自动保持连接数在所有机器之间的平衡，看着也很合理。可是我们的连接并不均衡啊！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020/02/alb-ingress.png&quot; alt=&quot;ALB Ingress&quot; /&gt;&lt;/p&gt;

&lt;p&gt;按照我当时的理解，如果有 3 个 Nginx Ingress，并且有 3 个连接，那么 AWS Load Balancer 会均衡分配连接。&lt;/p&gt;

&lt;p&gt;为了验证 AWS 有没有在忽悠我们，还是决定自己验证一下。AWS 遇到问题第一位帮我们解决问题的客服一般不会深入看我们的案例，只会找到一些文档并贴给我们。&lt;/p&gt;

&lt;p&gt;我们登上了宿主机并利用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ss&lt;/code&gt;看了下来自于 AWS Load Balancer 的 TCP 连接数，但是竟然找不到来自 AWS Load Balancer 的连接！&lt;/p&gt;

&lt;p&gt;嗯，有点懵了。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;理解底层原理&quot;&gt;理解底层原理&lt;/h4&gt;

&lt;p&gt;按照经验，遇到这种情况一般都是自己对某一块的理解不够充分，我们这里用了 NodePort 来暴露的 Nginx Ingress 服务，按照 Kubernetes 的解释，就算只有一个 Nginx Ingress 在运行，只要配置了 NodePort 后，整个集群任何一台宿主机的特定端口都可以访问到这个 Nginx Ingress 服务。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/docs/concepts/services-networking/service/#nodeport&quot;&gt;https://kubernetes.io/docs/concepts/services-networking/service/#nodeport&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当时对这块理解还不够深入，但仔细想想，这里是怎么做到的呢？常见的技术方案就是反向代理等技术。但如果是反向代理应该也能看到 TCP 连接。&lt;/p&gt;

&lt;p&gt;再仔细阅读文档和相关资料后，终于搞清楚了这块的原理。原来这里的原理和 Kubernetes 里访问&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Service&lt;/code&gt;的原理差不多，都是底层配置了 iptables 实现了 NAT 转发。&lt;/p&gt;

&lt;p&gt;那我们来看看 Kubernetes 生成的 iptables 规则具体是怎么样的，这里只保留 Nginx Ingress 相关的规则：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;iptables &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; nat &lt;span class=&quot;nt&quot;&gt;-L&lt;/span&gt;

Chain KUBE-NODEPORTS &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;1 references&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
target     prot opt &lt;span class=&quot;nb&quot;&gt;source               &lt;/span&gt;destination
KUBE-MARK-MASQ  tcp  &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;  anywhere             anywhere             /&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; ingress/nginx-controller:http &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;/ tcp dpt:30240
KUBE-SVC-RDGZDELSJT2I3HUE  tcp  &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;  anywhere             anywhere             /&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; ingress/nginx-controller:http &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;/ tcp dpt:30240

Chain KUBE-SVC-RDGZDELSJT2I3HUE &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;2 references&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
target     prot opt &lt;span class=&quot;nb&quot;&gt;source               &lt;/span&gt;destination
KUBE-SEP-UUSTZY7K4CEISA6G  all  &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;  anywhere             anywhere             statistic mode random probability 0.50000000000
KUBE-SEP-DUN7RLIPNVSKRQPN  all  &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;  anywhere             anywhere

Chain KUBE-SEP-UUSTZY7K4CEISA6G &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;1 references&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
target     prot opt &lt;span class=&quot;nb&quot;&gt;source               &lt;/span&gt;destination
KUBE-MARK-MASQ  all  &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;  ip-100-64-156-45.us-west-2.compute.internal  anywhere
DNAT       tcp  &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;  anywhere             anywhere             tcp to:100.64.156.45:80

Chain KUBE-SEP-DUN7RLIPNVSKRQPN &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;1 references&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
target     prot opt &lt;span class=&quot;nb&quot;&gt;source               &lt;/span&gt;destination
KUBE-MARK-MASQ  all  &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;  ip-100-64-229-39.us-west-2.compute.internal  anywhere
DNAT       tcp  &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;  anywhere             anywhere             tcp to:100.64.229.39:80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里可以看到 NodePort 指向了 Nginx Ingress 的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Service&lt;/code&gt;，然后&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Service&lt;/code&gt;的目标有 2 个，对应着两个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt;，并且是随机按概率访问的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020/02/alb-nat-ingress.png&quot; alt=&quot;ALB NAT Ingress&quot; /&gt;&lt;/p&gt;

&lt;p&gt;也就是说，就算 AWS Load Balancer 能严格控制连到各台宿主机的 TCP 连接数，但是最终进行 NAT 转发的时候是随机分配的，所以会出现上图这种情况。&lt;/p&gt;

&lt;p&gt;这也解释了为什么运行时间越长的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt;分配到的连接数越多了。因为每个新链接都是来一次随机分配，所以运行时间越长被分配到的连接就会越多。&lt;/p&gt;

&lt;p&gt;另外，想要看 NAT 转发的连接就需要用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;netstat-nat&lt;/code&gt;。最后终于确认，AWS 没有骗我们，从 AWS Load Balancer 的角度看，它的连接的确是均衡的。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;尝试从-nginx-ingress-这端解决问题&quot;&gt;尝试从 Nginx Ingress 这端解决问题&lt;/h4&gt;

&lt;p&gt;既然 AWS Load Balancer 不支持，那 Nginx Ingress 肯定支持这样的配置吧。&lt;/p&gt;

&lt;p&gt;搜索一番后找到了对应的配置，Nginx Ingress 支持上下游分别控制，配置分别是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;keep-alive-requests&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;upstream-keepalive-requests&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然而，事与愿违，CPU 还是不均衡。这次问题在哪？&lt;/p&gt;

&lt;p&gt;先尝试进入 Nginx Ingress 抓包，明明是有断开连接的，接下来再准备看看 Nginx Ingress 里的 TCP 连接情况。&lt;/p&gt;

&lt;p&gt;这时上面提到的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt;内抓包工具就不够用了，我还需要在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt;运行更多的命令。而容器化后的镜像大多是精简过的镜像，很多都直接把包管理干掉了，这也意味着你没办法直接进入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt;安装对应的工具。&lt;/p&gt;

&lt;p&gt;最后找到一个更好用的工具：&lt;a href=&quot;https://aleiwu.com/post/kubectl-debug-intro/&quot;&gt;简化 Pod 故障诊断: kubectl-debug 介绍&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;它可以用你自己的镜像，加入到目标容器的各种 namespace 中，文件系统是你自己的，网络却是共享的，这样就可以很方便地排查网路问题了。&lt;/p&gt;

&lt;p&gt;进入 Nginx Ingress “内部”后，看看 TCP 连接：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;State      Recv-Q       Send-Q              Local Address:Port                 Peer Address:Port
ESTAB      0            0                       127.0.0.1:http                    127.0.0.1:43094
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里就很奇怪了，为什么远端的 IP 是本地地址呢？之前同样是对 Istio 理解不深刻，并不知道入口流量也会被 Istio 劫持，后来查阅了相关文章后终于搞懂了技术细节：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.servicemesher.com/istio-handbook/concepts-and-principle/sidecar-injection-deep-dive.html&quot;&gt;Istio 中的 Sidecar 注入与流量劫持详解&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;原来这里 Nginx Ingress 只是断开了和 Envoy 之间的连接，而 Envoy 和 AWS Load Balancer 之间却没有断开。&lt;/p&gt;

&lt;p&gt;终于，一切现象都解释得通了。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;解决问题&quot;&gt;解决问题&lt;/h4&gt;

&lt;p&gt;所有的问题都搞清楚了，但是怎么解决呢？我们先来看看为什么 Istio 会拦截入口流量呢？流量控制只要拦截出口流量就行了。&lt;/p&gt;

&lt;p&gt;其实，这个也不难解释，Istio 遥测这块就需要拦截入口流量，才能知道这个服务的相关信息。&lt;/p&gt;

&lt;p&gt;而我们又禁用了 Mixer 模块，所以这个功能对我们来说是无用的，也就是说根本没必要让入口流量从 Envoy 走一遍，降低了性能还产生了问题。&lt;/p&gt;

&lt;p&gt;要禁用这个功能也不难，只要在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;annotation&lt;/code&gt;上加上&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;traffic.sidecar.istio.io/includeInboundPorts: &quot;&quot;&lt;/code&gt;，就可以不拦截任何入口流量了。&lt;/p&gt;

&lt;p&gt;配置后的确有效，最终解决了我们的问题。&lt;/p&gt;

&lt;p&gt;另外 Istio 也有一个全局的配置，然而配置了却没用，查看 Istio 源码后发现它根本没用过这个配置。&lt;/p&gt;

&lt;p&gt;自己解决也不难，就是改一下 yaml 文件而已，但是不理解他们的意图，还是先给官方提了个 Issue ：&lt;a href=&quot;https://github.com/istio/istio/issues/21458&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;global.proxy.includeInboundPorts&lt;/code&gt; is broken&lt;/a&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;自研-api-gateway&quot;&gt;自研 API Gateway&lt;/h3&gt;

&lt;p&gt;随着业务的发展，自研 API Gateway 的需求越来越大了，很多功能需要整合到 API Gateway 中，单纯的反向代理已经很难满足我们的需求了。&lt;/p&gt;

&lt;p&gt;相关需求有：智能路由，限流熔断，分布式追踪，统一身份校验，CDN 静态资源防盗链签名，I18N，安全防护等。&lt;/p&gt;

&lt;p&gt;正巧有一天看到了一篇 &lt;a href=&quot;https://caddyserver.com/&quot;&gt;Caddy&lt;/a&gt; Plugin 开发的技术文章，发现基于 Caddy 的插件机制开发一个 API Gateway 在开发效率，运行性能等方面都很有优势。我们内部已经有不少业务用 Golang 来实现了，Golang 在 Service Mesh 这块也很有优势。&lt;/p&gt;

&lt;p&gt;目前我们集群内所有流量都已经通过我们新开发的 API Gateway 来路由了，上述提到的需求我们也都已经实现。实现业务不难，难的是性能和稳定性。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;性能&quot;&gt;性能&lt;/h4&gt;

&lt;p&gt;讲真，用了 Golang 的 pprof 后发现真的是非常好用。&lt;/p&gt;

&lt;p&gt;经过压测和线上的分析后发现，主要的性能瓶颈就是 gzip, gunzip, json encode, json decode 等。可以发现这些都有一个共同的特点，大量的字符流和字节流的操作。&lt;/p&gt;

&lt;p&gt;gzip 和 json 相关的都是很常用的技术，网上也有了很多的优化库可以提升这块的性能：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/klauspost/compress&quot;&gt;https://github.com/klauspost/compress&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/valyala/fastjson&quot;&gt;https://github.com/valyala/fastjson&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这两个库简单地替换以后，CPU 使用率就降低了 20% 以上。它们的优化方向主要是对象复用，还有一些算法的改进。&lt;/p&gt;

&lt;p&gt;再往下看性能会发现大部分瓶颈都是在 GC 这块。这也是合情合理的，因为 API Gateway 作为一个反向代理，要把数据&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;decode&lt;/code&gt;后还要做大量处理，然后再&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;encode&lt;/code&gt;后返回给用户。这个过程和 gzip, json 处理类似，都是大量的字符流和字节流操作。&lt;/p&gt;

&lt;p&gt;所以优化的思路和上面提到的两个库差不多，优化算法+对象复用。&lt;/p&gt;

&lt;p&gt;因为这里的算法大多是特定业务的算法，不是像刷题算法那样是一个很单纯的问题，所以就不多介绍了，本质上就是一些文本处理的优化算法。而且这块收益也不是非常大。&lt;/p&gt;

&lt;p&gt;这里主要看一下对象复用带来的收益。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020/02/grafana-gateway-pool.png&quot; alt=&quot;Grafana Gateway Pool&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图是对象池取对象的每秒调用次数和新建对象的每秒调用次数对比，很明显用了对象池后，大部分对象都得到了复用，命中率非常高。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020/02/grafana-gateway-gc.png&quot; alt=&quot;Grafana Gateway GC&quot; /&gt;&lt;/p&gt;

&lt;p&gt;经过优化后，GC 次数和释放的数据也大大降低，CPU 使用率又有了大幅的降低。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;稳定性&quot;&gt;稳定性&lt;/h4&gt;

&lt;p&gt;API Gateway 上线运行一段时间后有一些问题，下游业务常常会因为底层数据库或者是别的什么原因导致卡了一下，这一瞬间的并发请求数就会非常大，单个实例就会到几千甚至几万的并发请求。&lt;/p&gt;

&lt;p&gt;大部分简单的 HTTP Server 都是多线程模式，每个请求由一个线程负责处理。当并发请求量一高，在 Java 中一个线程就要占用 1M 的栈，1000个并发请求就要占用 1G 的内存。一般 HTTP Server 都会在这种时候拒绝请求。&lt;/p&gt;

&lt;p&gt;高级点的 HTTP Server 可以把接收请求和处理请求解耦。接收请求的部分用 IO 复用来实现，几十万的连接都不在话下。而处理请求的部分还是一个请求一个线程，这样对业务写代码会更友好。两个部分再通过两个队列来整合在一起。&lt;/p&gt;

&lt;p&gt;而 Golang 就没这个烦恼了，Golang 协程的开销极小，编程的思路还是同步写法，但底层自动帮你处理了。于是它自信满满地把这些请求全部发送给了下游。&lt;/p&gt;

&lt;p&gt;当下游返回数据的时候它就懵了，虽然没有了线程的开销，但几万个请求同时在 API Gateway 内部处理，返回的数据 10k, 100k 是很常见的，还要在内存里 gunzip 一下，虽然处理能力比 Java 强得多，但到了上千近万还是扛不住。&lt;/p&gt;

&lt;p&gt;而 Golang 程序正常的时候占用内存极小，所以尽量节约资源，不会给它分配过多的内存，于是我们线上就经常会 OOM，一个实例 OOM，还会导致所有别的实例雪崩，线上还真的因此挂了很多次。&lt;/p&gt;

&lt;p&gt;一开始我们也是简单地和传统 HTTP Server 限制一下最大并发请求数，可是这个数字太小就会出现很多被拒绝的请求，太大又会 OOM。&lt;/p&gt;

&lt;p&gt;后来仔细想了想，这个问题对于 Golang 来说其实很好解决。一个请求过来后会检查当前并发请求数，如果数量太多就开始&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sleep&lt;/code&gt;自旋等待，最终要么等并发数降下去后继续执行，要么过了超时时间再抛错。&lt;/p&gt;

&lt;p&gt;这个功能上线后，API Gateway 自身的稳定性大大提高，再也不会因为下游的不稳定而造成 OOM 了，在几秒内的卡顿不仅不会 OOM，也不会拒绝任何一个请求。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020/02/gateway.png&quot; alt=&quot;Gateway&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面是我们的 API Gateway 长时间运行无重启的截图。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;后续&quot;&gt;后续&lt;/h4&gt;

&lt;p&gt;API Gateway 该实现的功能大多数都实现了，后面随着服务越来越多，规则配置变更也会很多。目前配置是打包在代码中的，后面会考虑把配置做成动态配置再加上一个管理界面。&lt;/p&gt;
</description>
				<pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate>
				<link>/2020/02/api-gateway.html</link>
				<guid isPermaLink="true">/2020/02/api-gateway.html</guid>
			</item>
		
			<item>
				<title>Service Mesh 实践（三）：数据库中间件</title>
				<description>&lt;h3 id=&quot;为什么要用数据库中间件&quot;&gt;为什么要用数据库中间件&lt;/h3&gt;

&lt;p&gt;严格的来说，数据库中间件的选择和 Servic Mesh 无关，一般公司很早就应该上数据库中间件了。&lt;/p&gt;

&lt;p&gt;数据库中间件一般有两个方案：SDK 模式或者 Proxy 模式。SDK 模式性能更好，Proxy 模式兼容性更好。&lt;/p&gt;

&lt;p&gt;既然我们都在往 Service Mesh 方向走了，就是不想在业务代码去接 SDK 了，所以 Proxy 模式是我们优先选择的方案。虽然延迟会高一点，但还是那句话，不要只盯着单次调用的延时。&lt;/p&gt;

&lt;p&gt;那数据库中间件到底解决了哪些问题？一般来说，利用数据库中间件可以实现如下功能：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;读写分离&lt;/li&gt;
  &lt;li&gt;分库分表&lt;/li&gt;
  &lt;li&gt;故障转移&lt;/li&gt;
  &lt;li&gt;动态配置&lt;/li&gt;
  &lt;li&gt;统计分析&lt;/li&gt;
  &lt;li&gt;SQL 防火墙&lt;/li&gt;
  &lt;li&gt;查询缓存&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;之前在大众点评做 &lt;a href=&quot;https://github.com/Meituan-Dianping/Zebra&quot;&gt;Zebra&lt;/a&gt; 的时候，主要的技术方案就是 SDK 模式，因为整个大众点评是 Java 技术栈，没有多语言的问题，所以用 SDK 模式可以尽量提高性能。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;从-mysql-到-aurora&quot;&gt;从 MySQL 到 Aurora&lt;/h3&gt;

&lt;p&gt;上面说了，数据库中间件在做 Service Mesh 之前就有这个需求了，但我们之前并没有做这块。原因就是 &lt;a href=&quot;https://aws.amazon.com/rds/aurora/&quot;&gt;Amazon Aurora&lt;/a&gt; 太好用了。&lt;/p&gt;

&lt;p&gt;以前在大众点评花了大量的时间做故障转移，但是 Aurora 直接全部帮你搞定了。&lt;/p&gt;

&lt;p&gt;Aurora 是 AWS 基于 MySQL 魔改出来的，这篇文章可以一窥 Aurora 的架构设计：&lt;a href=&quot;https://www.infoq.cn/article/kW4a9VbywO_XLiTizzB1&quot;&gt;Amazon Aurora 是如何设计原生云关系型数据库的？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;而读写分离和分库分表，我们因为只有一个单体程序，所以都是通过手写来实现的。并不是自动读写分离，自动分库分表。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;新的挑战&quot;&gt;新的挑战&lt;/h3&gt;

&lt;p&gt;虽然 Aurora 帮我们解决了故障转移这个最棘手的问题，但是别的还是要自己来做。微服务化后，很多轻量级的服务出现，它们只需要基本的读写分离功能，并不希望为了这个再去整合什么 SDK；另外我们涉及到的开发语言也不少。&lt;/p&gt;

&lt;p&gt;能否用 Proxy 模式来解决这个问题？Proxy 模式的数据库中间件也是一个非常常见的技术方案。另外这两个方案也并不冲突，完全可以根据不同的业务类型来使用不同的技术方案。&lt;/p&gt;

&lt;p&gt;而我们现在是快速迭代试错的阶段，所以找到一个满足我们需求的 Proxy 是第一位的。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;mycat-与-shardingsphere&quot;&gt;MyCAT 与 ShardingSphere&lt;/h3&gt;

&lt;p&gt;因为之前是 Java 技术栈，那么自然先找到了两个 Java 开发的两大中间件了。&lt;/p&gt;

&lt;p&gt;MyCAT 成名早，ShardingSphere 是后起之秀，知乎上有一篇两者的对比文章特别有意思：&lt;a href=&quot;https://www.zhihu.com/question/64709787&quot;&gt;mycat和sharding-jdbc哪个比较好？各有什么优缺点？
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;说真的，的确受不了 MyCAT 的土味气息。而 ShardingSphere 就靠谱多了，首先是在京东有大规模实践，代码完全开源并归属于开源社区，开源运作方式也很标准。&lt;/p&gt;

&lt;p&gt;最最重要的就是知乎上提到的，ShardingSphere 的官网和文档好太多了。&lt;/p&gt;

&lt;p&gt;然而使用 ShardingSphere 的过程也没那么顺利。一开始就遇到了两个问题，我也给官方提了 issue。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/apache/incubator-shardingsphere/issues/1533&quot;&gt;The result of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getBytes&lt;/code&gt; is wrong.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/apache/incubator-shardingsphere/issues/1506&quot;&gt;Does sharding-proxy support hint?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;例如第一个问题，因为 JDBC 规范也挺熟悉了，所以尝试自己去修复一下，但看到他们代码内的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Binary&lt;/code&gt;相关的 MySQL 字段都是处理错误的，心凉了半截。讲真代码还是有点乱的，他们&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Binary&lt;/code&gt;这块的逻辑并没有理得很清楚。&lt;/p&gt;

&lt;p&gt;当时他们刚开源不久，也还没有加入 Apache 基金会，虽然现在上面两个问题都已经解决，但基于当时的情况，还是不敢用的。另外 Java 在容器化下的慢启动和高内存问题也是我不太敢用 Java 中间件的原因。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;proxysql&quot;&gt;ProxySQL&lt;/h3&gt;

&lt;p&gt;后来继续搜寻相关中间件的时候偶然发现了 &lt;a href=&quot;https://www.proxysql.com/&quot;&gt;ProxySQL&lt;/a&gt;，于是决定尝试一下。&lt;/p&gt;

&lt;p&gt;它可以解决上面提到了所有数据库中间件需要解决的问题。&lt;/p&gt;

&lt;p&gt;然而，万万没想到，刚开始试用就遇上了 Bug：&lt;a href=&quot;https://github.com/sysown/proxysql/issues/1860&quot;&gt;ProxySQL hangs after run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set names 'binary'&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果不设置这个，MySQL 会认为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'a' = 'ä'&lt;/code&gt;，因为我们是面向全球用户的 APP，很多用户的用户名会用这些字符，这个参数是否设置对结果影响很大，可以看 MySQL 的官方文档：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/charset-binary-collations.html&quot;&gt;The binary Collation Compared to _bin Collations&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/charset-binary-set.html&quot;&gt;The Binary Character Set&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我给作者提了 Issue，作者响应也非常快，一天内就给我反馈了。他问了我一些细节，也让我帮他抓包看看。&lt;/p&gt;

&lt;p&gt;最后大概一个月过后，他把这个 Bug 修复了，并发布了新版本。&lt;/p&gt;

&lt;p&gt;而在他修复 Bug 期间，我们其实已经用起来了，因为当时迁移的业务不包含这样子的特殊文本比较，所以不会命中这个 Bug。&lt;/p&gt;

&lt;p&gt;整体的使用过程中是非常可靠的，因为 ProxySQL 是 C++ 写的，而且作为 Proxy 主要功能也只是做一些转发，所以 CPU 和内存消耗非常小，启动也非常快。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;proxysql-配置&quot;&gt;ProxySQL 配置&lt;/h3&gt;

&lt;p&gt;我们目前通过 ProxySQL 实现了读写分离，强制主库 Hint 和非法 SQL 拦截。这里可以给配置作为参考：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql_servers =
(
    {
        address = &quot;[change to your mysql master server]&quot; # no default, required
        port = 3306                                      # no default, required
        hostgroup = 0                                    # no default, required
        status = &quot;ONLINE&quot;                                # default: ONLINE
        weight = 1                                       # default: 1
        compression = 0                                  # default: 0
    },
    {
        address = &quot;[change to your mysql slave server]&quot;  # no default, required
        port = 3306                                      # no default, required
        hostgroup = 1                                    # no default, required
        status = &quot;ONLINE&quot;                                # default: ONLINE
        weight = 1                                       # default: 1
        compression = 0                                  # default: 0
    }
)

#defines MySQL Query Rules
mysql_query_rules:
(
    {
        rule_id=0
        active=1
        match_pattern=&quot;^\s*UPDATE (?!.[\s\S]*(where))&quot;
        destination_hostgroup=1
        apply=0
        flagOUT=403
    },
    {
        rule_id=1
        active=1
        match_pattern=&quot;^\s*DELETE (?!.[\s\S]*(where))&quot;
        destination_hostgroup=1
        apply=0
        flagOUT=403
    },
    {
        rule_id=2
        active=1
        match_pattern=&quot;^\s*/\*master\*/&quot;
        destination_hostgroup=0
        apply=1
    },
    {
        rule_id=3
        active=1
        match_pattern=&quot;^\s*SELECT [\s\S]* FOR UPDATE$&quot;
        destination_hostgroup=0
        apply=1
    },
    {
        rule_id=4
        ctive=1
        match_pattern=&quot;^\s*SELECT&quot;
        destination_hostgroup=1
        apply=1
    },
    {
        rule_id=1001
        active=1
        apply=1
        flagIN=403
        error_msg=&quot;Query not allowed&quot;
    }
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;前面两条规则是禁止使用没有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WHERE&lt;/code&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UPDATE&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DELETE&lt;/code&gt;，这个是血泪史，有同事在线上出过事。还好当时那张表太大，没有执行完就赶紧终止掉了。不然就真是的从删库到跑路了。&lt;/p&gt;

&lt;p&gt;第三条是支持强制走写库，因为 ProxySQL 实现了自动读写分离，业务不需要整合任何框架。但是有时候业务就是需要&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SELECT&lt;/code&gt;语句强制走写库，那么这时候只要在 SQL 语句前面加上注释就行了。&lt;/p&gt;

&lt;p&gt;用法：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/*master*/SELECT * FROM users LIMIT 1&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;第四条支持&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SELECT * FROM user FOR UPDATE&lt;/code&gt;强制走写库。这条 SQL 语句是在同一个事务中为了后续更新数据，读取数据并加锁的操作。&lt;/p&gt;

&lt;p&gt;第五条规则就是默认所有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SELECT&lt;/code&gt;走从库了。&lt;/p&gt;

&lt;p&gt;最后一个是一个通用行为，第一条和第二条规则会跳转到这里。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;proxysql-基准测试与性能调优&quot;&gt;ProxySQL 基准测试与性能调优&lt;/h3&gt;

&lt;p&gt;如果把它作为长久的方案，那跑一下符合我们环境的基准测试还是必须的。需要了解一下在有 Proxy 和没 Proxy 下的性能区别，各个版本 ProxySQL 的性能区别，还有不同负载下的性能区别。&lt;/p&gt;

&lt;p&gt;这里我也做了个基于 Sysbench 的工具可以方便地做 ProxySQL 基准测试，对不同版本，不同参数的对比很有参考意义。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/dozer47528/proxysql-benchmark&quot;&gt;https://github.com/dozer47528/proxysql-benchmark&lt;/a&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;极限压力测试&quot;&gt;极限压力测试&lt;/h4&gt;

&lt;p&gt;首先测试一下不限制 Sysbench 的 rate，用尽全力去压测。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MySQL: CPU 2, Memory 4Gi, Max Connection 2048&lt;/li&gt;
  &lt;li&gt;ProxySQL: CPU 1, Memory 256Mi, Max Connection 2048&lt;/li&gt;
  &lt;li&gt;Sysbench: CPU 1, Memory 1Gi&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Threads&lt;/th&gt;
      &lt;th&gt;MySQL Min&lt;/th&gt;
      &lt;th&gt;ProxySQL Min&lt;/th&gt;
      &lt;th&gt;MySQL Avg&lt;/th&gt;
      &lt;th&gt;ProxySQL Avg&lt;/th&gt;
      &lt;th&gt;MySQL Max&lt;/th&gt;
      &lt;th&gt;ProxySQL Max&lt;/th&gt;
      &lt;th&gt;MySQL P95&lt;/th&gt;
      &lt;th&gt;ProxySQL P95&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;1.38 ms&lt;/td&gt;
      &lt;td&gt;5.65 ms&lt;/td&gt;
      &lt;td&gt;8.40 ms&lt;/td&gt;
      &lt;td&gt;8.63 ms&lt;/td&gt;
      &lt;td&gt;72.90 ms&lt;/td&gt;
      &lt;td&gt;215.26 ms&lt;/td&gt;
      &lt;td&gt;38.94 ms&lt;/td&gt;
      &lt;td&gt;13.22 ms&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;50&lt;/td&gt;
      &lt;td&gt;1.39 ms&lt;/td&gt;
      &lt;td&gt;5.60 ms&lt;/td&gt;
      &lt;td&gt;42.66 ms&lt;/td&gt;
      &lt;td&gt;44.50 ms&lt;/td&gt;
      &lt;td&gt;280.67 ms&lt;/td&gt;
      &lt;td&gt;224.27 ms&lt;/td&gt;
      &lt;td&gt;92.42 ms&lt;/td&gt;
      &lt;td&gt;82.96 ms&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;1.47 ms&lt;/td&gt;
      &lt;td&gt;5.54 ms&lt;/td&gt;
      &lt;td&gt;87.65 ms&lt;/td&gt;
      &lt;td&gt;87.22 ms&lt;/td&gt;
      &lt;td&gt;605.22 ms&lt;/td&gt;
      &lt;td&gt;504.15 ms&lt;/td&gt;
      &lt;td&gt;189.93 ms&lt;/td&gt;
      &lt;td&gt;155.80 ms&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;500&lt;/td&gt;
      &lt;td&gt;4.32 ms&lt;/td&gt;
      &lt;td&gt;13.20 ms&lt;/td&gt;
      &lt;td&gt;569.17 ms&lt;/td&gt;
      &lt;td&gt;436.58 ms&lt;/td&gt;
      &lt;td&gt;2751.15 ms&lt;/td&gt;
      &lt;td&gt;3829.34 ms&lt;/td&gt;
      &lt;td&gt;893.56 ms&lt;/td&gt;
      &lt;td&gt;831.46 ms&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020/02/mysql-proxysql-full.png&quot; alt=&quot;Full&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从结果可以看出来并发量增加后最后的瓶颈都是 MySQL 了，并且随着并发量的增加，ProxySQL 的性能损耗基本是常数级别的，Avg 这一栏在并发数是 10,50 的时候都是慢 2ms 左右。&lt;/p&gt;

&lt;p&gt;因为 ProxySQL 不会做额外的计算，所以不会因为 MySQL 压力大而影响自身性能。&lt;/p&gt;

&lt;p&gt;但这种把 MySQL 往死里压的场景其实很少，只有 MySQL 故障的时候才会出现。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;限制-sysbench-rate&quot;&gt;限制 Sysbench rate&lt;/h4&gt;

&lt;p&gt;平日里，MySQL 一般都不会是满负载运行，一般来说连接会很多，但大部分连接都不会一直在请求。所以我在这里尝试把 Sysbench 每秒请求速率控制一下，保证不把 MySQL 压垮。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MySQL: CPU 2, Memory 4Gi, Max Connection 2048&lt;/li&gt;
  &lt;li&gt;ProxySQL: CPU 1, Memory 256Mi, Max Connection 2048&lt;/li&gt;
  &lt;li&gt;Sysbench: CPU 1, Memory 1Gi, Rate 256/s&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Threads&lt;/th&gt;
      &lt;th&gt;MySQL Min&lt;/th&gt;
      &lt;th&gt;ProxySQL Min&lt;/th&gt;
      &lt;th&gt;MySQL Avg&lt;/th&gt;
      &lt;th&gt;ProxySQL Avg&lt;/th&gt;
      &lt;th&gt;MySQL Max&lt;/th&gt;
      &lt;th&gt;ProxySQL Max&lt;/th&gt;
      &lt;th&gt;MySQL P95&lt;/th&gt;
      &lt;th&gt;ProxySQL P95&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;3.24 ms&lt;/td&gt;
      &lt;td&gt;4.37 ms&lt;/td&gt;
      &lt;td&gt;3.82 ms&lt;/td&gt;
      &lt;td&gt;4.95 ms&lt;/td&gt;
      &lt;td&gt;33.06 ms&lt;/td&gt;
      &lt;td&gt;15.21 ms&lt;/td&gt;
      &lt;td&gt;4.33 ms&lt;/td&gt;
      &lt;td&gt;5.37 ms&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;50&lt;/td&gt;
      &lt;td&gt;3.23 ms&lt;/td&gt;
      &lt;td&gt;4.52 ms&lt;/td&gt;
      &lt;td&gt;3.84 ms&lt;/td&gt;
      &lt;td&gt;5.10 ms&lt;/td&gt;
      &lt;td&gt;12.34 ms&lt;/td&gt;
      &lt;td&gt;14.20 ms&lt;/td&gt;
      &lt;td&gt;4.33 ms&lt;/td&gt;
      &lt;td&gt;5.57 ms&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;3.24 ms&lt;/td&gt;
      &lt;td&gt;4.55 ms&lt;/td&gt;
      &lt;td&gt;3.82 ms&lt;/td&gt;
      &lt;td&gt;5.21 ms&lt;/td&gt;
      &lt;td&gt;11.91 ms&lt;/td&gt;
      &lt;td&gt;13.97 ms&lt;/td&gt;
      &lt;td&gt;4.41 ms&lt;/td&gt;
      &lt;td&gt;5.77 ms&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;500&lt;/td&gt;
      &lt;td&gt;3.25 ms&lt;/td&gt;
      &lt;td&gt;5.04 ms&lt;/td&gt;
      &lt;td&gt;3.87 ms&lt;/td&gt;
      &lt;td&gt;6.05 ms&lt;/td&gt;
      &lt;td&gt;12.26 ms&lt;/td&gt;
      &lt;td&gt;17.71 ms&lt;/td&gt;
      &lt;td&gt;4.49 ms&lt;/td&gt;
      &lt;td&gt;6.91 ms&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1000&lt;/td&gt;
      &lt;td&gt;3.23 ms&lt;/td&gt;
      &lt;td&gt;5.73 ms&lt;/td&gt;
      &lt;td&gt;3.84 ms&lt;/td&gt;
      &lt;td&gt;7.56 ms&lt;/td&gt;
      &lt;td&gt;14.47 ms&lt;/td&gt;
      &lt;td&gt;17.80 ms&lt;/td&gt;
      &lt;td&gt;4.41 ms&lt;/td&gt;
      &lt;td&gt;8.90 ms&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2000&lt;/td&gt;
      &lt;td&gt;3.21 ms&lt;/td&gt;
      &lt;td&gt;7.99 ms&lt;/td&gt;
      &lt;td&gt;3.84 ms&lt;/td&gt;
      &lt;td&gt;11.15 ms&lt;/td&gt;
      &lt;td&gt;48.86 ms&lt;/td&gt;
      &lt;td&gt;45.65 ms&lt;/td&gt;
      &lt;td&gt;4.41 ms&lt;/td&gt;
      &lt;td&gt;17.63 ms&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020/02/mysql-proxysql-rate.png&quot; alt=&quot;Rate&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在这样的压力下，MySQL 非常稳，而 ProxySQL 的性能却随着连接数的增加而变差了。良好设计后的数据库实例本身就应该由单一的几个业务访问，而不是让服务都能访问，所以在 1000 以下的连接数下的性能损耗完全是可以接受的。&lt;/p&gt;

&lt;p&gt;是否可以尝试改善一下大量连接下的性能？ProxySQL 默认 4 个线程，Sysbench 并发高的话 4 个线程会不会太小？&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;尝试提升-proxysql-线程数&quot;&gt;尝试提升 ProxySQL 线程数&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;MySQL: CPU 2, Memory 4Gi, Max Connection 2048&lt;/li&gt;
  &lt;li&gt;ProxySQL: CPU 1, Memory 256Mi, Max Connection 2048, Threads 8&lt;/li&gt;
  &lt;li&gt;Sysbench: CPU 1, Memory 1Gi, Rate 256/s&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Sysbench Threads&lt;/th&gt;
      &lt;th&gt;ProxySQL Threads&lt;/th&gt;
      &lt;th&gt;Min&lt;/th&gt;
      &lt;th&gt;Avg&lt;/th&gt;
      &lt;th&gt;Max&lt;/th&gt;
      &lt;th&gt;P95&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1000&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;5.73 ms&lt;/td&gt;
      &lt;td&gt;7.56 ms&lt;/td&gt;
      &lt;td&gt;17.80 ms&lt;/td&gt;
      &lt;td&gt;8.90 ms&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1000&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;4.97 ms&lt;/td&gt;
      &lt;td&gt;6.01 ms&lt;/td&gt;
      &lt;td&gt;50.00 ms&lt;/td&gt;
      &lt;td&gt;6.91 ms&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2000&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;7.99 ms&lt;/td&gt;
      &lt;td&gt;11.15 ms&lt;/td&gt;
      &lt;td&gt;45.65 ms&lt;/td&gt;
      &lt;td&gt;17.63 ms&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2000&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;5.68 ms&lt;/td&gt;
      &lt;td&gt;7.54 ms&lt;/td&gt;
      &lt;td&gt;58.87 ms&lt;/td&gt;
      &lt;td&gt;9.91 ms&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这里就出现了一个很有意思的现象了，除了 Max 外别的都降低了。&lt;/p&gt;

&lt;p&gt;如果它并发做得好，在线程数大于 CPU 核心数的前提下，线程数越少越好。&lt;/p&gt;

&lt;p&gt;官方的一个 Issue 也很好地解释了应该如何配置线程数：&lt;a href=&quot;https://github.com/sysown/proxysql/issues/1166&quot;&gt;How can i find the correct number of mysql-threads&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;但为什么我配置的 CPU &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;limits&lt;/code&gt; 是 1，加大了线程数却有效果呢？因为 Kubernetes &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;limits&lt;/code&gt; 里配置的 1 不是给你一个核，而是指相当于一个核的 CPU 时间。&lt;/p&gt;

&lt;p&gt;这篇文章讲解的很好：&lt;a href=&quot;https://medium.com/expedia-group-tech/kubernetes-container-resource-requirements-part-2-cpu-83ca227a18b1&quot;&gt;Kubernetes Container Resource Requirements — Part 2: CPU&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;举个例子就是在 1 秒内让一个工人给你工作 1 秒和在 1 秒内让 4 个工人分别给你工作 0.25 秒 的区别。&lt;/p&gt;

&lt;p&gt;我的电脑是 8 核的 CPU，所以配置成 8 个线程后整体延迟下降了。但是，虽然 8 个核都可以用到，但都是残血的。所以有些线程跑到一半资源又被别的线程抢过去了，导致 Max 增加。&lt;/p&gt;

&lt;p&gt;所以在容器化下跑这些东西还是要压测一下真实数据才更靠谱。&lt;/p&gt;

&lt;p&gt;后面还要继续调优 ProxySQL 的话，可以看看官方文档，还有这里有些博客，也有很多介绍：&lt;a href=&quot;https://www.junmajinlong.com/mysql/index/#3-2-MySQL-%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%9AProxySQL&quot;&gt;MySQL-中间件：ProxySQL&lt;/a&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;后续&quot;&gt;后续&lt;/h3&gt;

&lt;p&gt;目前 ProxySQL 连接数在 1000 以下的情况下性能完全够用，后面我们要重度使用的话，还是要做一下性能调优的。&lt;/p&gt;

&lt;p&gt;另外 ProxySQL 本身把所有配置写入了自己内置的一个数据库中，启动的时候可以读一份配置，运行的时候也可以直接修改。后面数据库实例多了，做一些管理工具是必须的。&lt;/p&gt;

&lt;p&gt;还有 ProxySQL 自身监控数据也已经非常多了，但还是需要做一些整合，例如配合 Prometheus 和 Grafana，把它们呈现出来。&lt;/p&gt;
</description>
				<pubDate>Sun, 23 Feb 2020 00:00:00 +0000</pubDate>
				<link>/2020/02/database-middleware.html</link>
				<guid isPermaLink="true">/2020/02/database-middleware.html</guid>
			</item>
		
			<item>
				<title>Service Mesh 实践（二）：Istio Mixer 模块的性能问题与替代方案</title>
				<description>&lt;h3 id=&quot;寄以厚望的-mixer&quot;&gt;寄以厚望的 Mixer&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://istio.io/docs/ops/deployment/architecture/&quot;&gt;Istio Architecture&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Istio 的架构设计让人看着非常舒服，分工明确，扩展性强。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020/02/istio-arch.png&quot; alt=&quot;The overall architecture of an Istio-based application.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;特别是 Mixer 模块，包含&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Telemetry&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Policy Check&lt;/code&gt;两个模块，数据平面的 Envoy 会把所有请求异步发送给 Mixer 用作遥测，也会定时检查对应规则判断是否可以调用目标服务。&lt;/p&gt;

&lt;p&gt;数据平面会把所有的请求上报到 Mixer，如果想要扩展任何功能，只需要扩展 Mixer 就行了。Istio 也把这一层做成了 &lt;a href=&quot;https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/&quot;&gt;CRDs&lt;/a&gt;，只需要创建对应的 CRDs 就可以了，而不需要对数据平面做任何改动。&lt;/p&gt;

&lt;p&gt;按照 Istio 的理念，遥测和规则检查是属于控制平面的，从解耦的角度看，这样的设计很棒。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;残酷的现实&quot;&gt;残酷的现实&lt;/h3&gt;

&lt;p&gt;然而，随着 Istio 1.0 的发布，大家纷纷用上后都发现 Mixer 的性能影响很大。&lt;/p&gt;

&lt;p&gt;第一个影响是 Mixer 会导致延迟变高，根据 Istio 官方的 &lt;a href=&quot;https://istio.io/docs/ops/deployment/performance-and-scalability/&quot;&gt;Benchmark&lt;/a&gt;，文中可以看到 P90 Lantency 在加了 Mixer 以后差了一个数量级。&lt;/p&gt;

&lt;p&gt;官方 Benchmark 中有这么一句话：In upcoming Istio releases we are moving istio-policy and istio-telemetry functionality into the proxy as TelemetryV2.&lt;/p&gt;

&lt;p&gt;最近，Istio 团队也意识到了这个问题，并已经开始重构。据说即将发布的 Istio 1.5 就会把 Mixer 整合进 Envoy 中。这样减少了额外的远程调用，可以减少延迟降低 CPU 消耗。&lt;/p&gt;

&lt;p&gt;其实再去回看蚂蚁金服的 &lt;a href=&quot;https://www.sofastack.tech/projects/sofa-mesh/overview/&quot;&gt;SOFAMesh&lt;/a&gt; 就会发现，SOFAMesh 在很早就意识到了这个问题，并且着手进行了改造。直接把 Envoy 用自研的模块取代，并把 Mixer 整合进去了。整个改造思路和 Istio 未来的设计是类似的。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;mixer-到底有什么用&quot;&gt;Mixer 到底有什么用&lt;/h3&gt;

&lt;p&gt;我们的解决方案非常简单，直接把 Mixer 模块禁用了。这肯定不是一个简单的决定，这肯定是根据我们现状决定的。&lt;/p&gt;

&lt;p&gt;首先看看 Mixer 能给我们提供什么。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;policy-check&quot;&gt;Policy Check&lt;/h4&gt;

&lt;p&gt;以我们现在的公司规模，内部是不需要什么服务之间的访问权限控制的，因为内部的“漏洞”太多了，就算你把这里堵住了，真的想搞事的人有大把手段可以绕过这个限制。所以这个功能暂时对我们来说是没什么意义的。&lt;/p&gt;

&lt;p&gt;我们很早就把&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Policy Check&lt;/code&gt;给禁用了。&lt;/p&gt;

&lt;p&gt;如果每个 Istio 版本更新你都看了的话，你会发现很早以前 Istio 是默认开启&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Policy Check&lt;/code&gt;的，而当前版本，默认就禁用了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Policy Check&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;可见这个功能对大部分人来说是不需要的。&lt;/p&gt;

&lt;p&gt;禁用掉&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Policy Check&lt;/code&gt;后，P95 好了很多，因为之前它需要定期去检查各种规则。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;telemetry&quot;&gt;Telemetry&lt;/h4&gt;

&lt;p&gt;Istio 里的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Telemetry&lt;/code&gt;主要有这些：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.jaegertracing.io/&quot;&gt;Jaeger&lt;/a&gt; 或 &lt;a href=&quot;https://zipkin.io/&quot;&gt;Zipkin&lt;/a&gt; 负责分布式追踪&lt;/li&gt;
  &lt;li&gt;Prometheus + Grafana 负责监控和告警&lt;/li&gt;
  &lt;li&gt;Access Log 会被统一搜集到 Mixer&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;先说说分布式追踪，分布式追踪不侵入代码是不可能的。如果你不改任何代码直接在 Istio 里启用分布式追踪，它会有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A -&amp;gt; B&lt;/code&gt;的调用，也会有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B -&amp;gt; C&lt;/code&gt;的调用，但是没有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A -&amp;gt; B -&amp;gt; C&lt;/code&gt;，也就是说不能把它们串起来。&lt;/p&gt;

&lt;p&gt;为什么串不起来呢？因为作为 Sidecar 是不侵入代码的，只能观测到所有进出的流量。而对于 Sidecar 来说它观测到的进出请求同时会有很多，如果没有什么特殊的标记，它并不知道它们之间的关系，因此也无法把整个调用链串起来了。&lt;/p&gt;

&lt;p&gt;一般 RPC 都会有一个类似&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RequestId&lt;/code&gt;的东西，并且会在所有调用中透传，而 HTTP 或 gRPC 现在并没有相关的协议。所以你必须在自己的代码里手工或利用 SDK 来透传。&lt;/p&gt;

&lt;p&gt;除此以外，你想做分布式追踪那么代码内部的一些细节你肯定也是想知道的。例如内部调用了几次数据库，分别耗时多少等。光看服务之间的 RPC 调用，颗粒度还是太粗了。&lt;/p&gt;

&lt;p&gt;对于分布式追踪来说，侵入代码是必须的，SDK 能帮你尽量少动代码，但无法避免引入对应的 SDK。像 Java 很简单，引一些依赖配合 Spring 就自动处理了，而 Golang 都是需要自己手动改代码的。&lt;/p&gt;

&lt;p&gt;所以 Sidecar 模式对分布式追踪来说基本没什么帮助，最后还是要靠自己。&lt;/p&gt;

&lt;p&gt;再说 Prometheus + Grafana 来做监控和告警。&lt;/p&gt;

&lt;p&gt;Prometheus 本身技术方案是完全不影响业务代码性能的，业务代码把数据放自己内存里暴露一个接口，Prometheus 主动去抓取。一般频率也就一分钟一次，所以对业务是无影响的。然后 Istio 搜集各种指标的时候是先发送给 Mixer 然后再由 Mixer 上报到 Prometheus。&lt;/p&gt;

&lt;p&gt;另外 Istio 的 Prometheus 也无法统计自定义的指标，所以整个集群建 Prometheus 是必须的。Istio 的 Prometheus 并没有太大的优势。&lt;/p&gt;

&lt;p&gt;最后看 Access Log，首先我觉得在正常情况下内部服务之间的 Access Log 是没必要完全搜集的。微服务化后，服务之间的调用相当于以前代码间的调用。以前你会把所有方法调用的日志记录下来吗？真的没有必要。除非是在做问题排查的时候，应该按需启用。&lt;/p&gt;

&lt;p&gt;早期版本的 Istio 默认会启用 Sidecar 的 Access Log 并且全部上报给了 Mixer，对整体性能影响非常大。我们通过配置禁用了。但近期的几个版本 Istio 默认也不搜集 Access Log 了。&lt;/p&gt;

&lt;p&gt;另外如果你真的有搜集 Access Log 的需求，完全可以用 Fluent Bit 做成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DaemonSet&lt;/code&gt;直接到宿主机上搜集日志。直接读取日志文件，对业务也完全没有影响。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;改造方案&quot;&gt;改造方案&lt;/h3&gt;

&lt;p&gt;最后，我们的方案就是去掉 Mixer 模块，自己搭建 Jaeger、Prometheus、Grafana 还有 Fluent Bit。&lt;/p&gt;

&lt;p&gt;每个模块都以自己性能最佳的方式去得到自己的数据，而不是像 Mixer 一样，先把数据全部汇总，然后再用适配器模式适配成各种需要的数据。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;elastic-apm&quot;&gt;Elastic APM&lt;/h3&gt;

&lt;p&gt;后来，我们又发现了一个好用的东西，那就是 &lt;a href=&quot;https://www.elastic.co/cn/apm&quot;&gt;Elastic APM&lt;/a&gt;，从名字上可以看出，它的功能高于 Jaeger，不仅仅做了分布式追踪，还做了以前 Istio 内置 Prometheus + Grafana 做的指标功能。&lt;/p&gt;

&lt;p&gt;界面和易用性上也完全不是一个水平的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020/02/elastic-apm.png&quot; alt=&quot;Elastic APM UI&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当然它也不是完美无缺的，我们也对它稍微进行了一些小改动，它本身的功能迭代也非常快，是很好的 Jeager 替代者。&lt;/p&gt;

&lt;p&gt;另外，Elastic APM 不遵行 &lt;a href=&quot;https://opentracing.io/&quot;&gt;Opentracing&lt;/a&gt; 标准，Jeager 遵行 Opentracing 标准，Opentracing 标准里包含一个支持分布式上下文的功能。这个对微服务化来说很重要，之前说过这个功能一般是 RPC 来支持的，但是我们用的是 HTTP 和 gRPC。&lt;/p&gt;

&lt;p&gt;关于这个问题，后面还会有详细的介绍，详细介绍了我们的解决方案。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;未来&quot;&gt;未来&lt;/h3&gt;

&lt;p&gt;基于上面的分析，除了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Policy Check&lt;/code&gt;以外，遥测相关的功能用 Sidecar 模式并不是一个很好的方案。这些功能对性能要求很高。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Policy Check&lt;/code&gt;放到 Sidecar 里还是很有用的，期待新版本的 Istio 能把 Mixer 整合到数据平面，大幅度改善这块的性能。&lt;/p&gt;

&lt;p&gt;到时候等我们需要&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Policy Check&lt;/code&gt;，我们会考虑重新把 Mixer 启用。&lt;/p&gt;

&lt;p&gt;其实在实践中我们也慢慢的发现，Sidecar 模式并不是一颗银弹。流量控制这块真的很好用，完全解耦，Sidecar 并不需要业务具体使用什么语言写的。但 Sidecar 模式并不能解决所有问题，很多时候还是应该用更合适的方案去解决问题。&lt;/p&gt;
</description>
				<pubDate>Fri, 21 Feb 2020 00:00:00 +0000</pubDate>
				<link>/2020/02/replace-istio-mixer.html</link>
				<guid isPermaLink="true">/2020/02/replace-istio-mixer.html</guid>
			</item>
		
			<item>
				<title>Service Mesh 实践（一）：从 kops 到 ESK</title>
				<description>&lt;h3 id=&quot;kops-问题出在哪&quot;&gt;kops 问题出在哪？&lt;/h3&gt;

&lt;p&gt;如果仅从易用性这个角度看，kops 是完胜 EKS 的，下面有一个官方的演示视频。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://asciinema.org/a/97298&quot;&gt;kops 演示视频&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;所有的操作都可以在命令行里完成，包括建集群，改集群。&lt;/p&gt;

&lt;p&gt;每次变更都需要如下几个步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;编辑 yaml 配置。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kops update cluster&lt;/code&gt;，这一步相当于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dry run&lt;/code&gt;，你可以检查即将产生的变更。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kops update cluster --yes&lt;/code&gt;，这一步才是把配置推到线上。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kops rolling-update cluster&lt;/code&gt;，这里也是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dry run&lt;/code&gt;，上一步虽然把配置推送到线上了，但有些机器的配置需要重建机器。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kops rolling-update cluster --yes&lt;/code&gt;，最后它会按顺序一台台更新机器。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;整个集群升级过程非常直观可控，再配合 Kubernetes 的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PodDisruptionBudget&lt;/code&gt;，整个升级过程会变得非常安全。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PodDisruptionBudget&lt;/code&gt;可以控制一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Deployment&lt;/code&gt;至少存活多少&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt;，保证服务可用。否则如果一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Deployment&lt;/code&gt;的两个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt;凑巧在一台机器上，没有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PodDisruptionBudget&lt;/code&gt;的话它就直接干掉了。&lt;/p&gt;

&lt;p&gt;然而， kops 在 Master 节点的可靠性上出了点问题。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;kops-111-到-112&quot;&gt;kops 1.11 到 1.12&lt;/h3&gt;

&lt;p&gt;我们第一个遇到的问题是 kops 升级到 1.12 后的一个架构大改动。当时是 2019 年第二季度左右。&lt;/p&gt;

&lt;p&gt;官方介绍：&lt;a href=&quot;https://github.com/kubernetes/kops/blob/master/docs/etcd3-migration.md&quot;&gt;https://github.com/kubernetes/kops/blob/master/docs/etcd3-migration.md&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Kubernetes is moving from etcd2 to etcd3, which is an upgrade that involves Kubernetes API Server downtime. Technically there is no usable upgrade path from etcd2 to etcd3 that supports HA scenarios, but kops has enabled it using etcd-manager.&lt;/p&gt;

&lt;p&gt;可怕，这个升级过程没有可用的高可用方案，必须要有宕机时间。而最可怕的事情就是，Master 节点在整个 Kubernetes 集群中是非常重要的。&lt;/p&gt;

&lt;p&gt;首先无法调度就算了，升级期间无法起新的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt;也可以接受，一般也在低峰期升级。&lt;/p&gt;

&lt;p&gt;我们网络插件是 &lt;a href=&quot;https://www.projectcalico.org/&quot;&gt;Calico&lt;/a&gt;，Master 节点上的 Kubernetes API Server 长时间宕机会直接导致 Calico 无法获取其他机器的信息从而导致机器之间的网络故障。&lt;/p&gt;

&lt;p&gt;除此以外，CoreDNS 也依赖 Kubernetes API Server，长时间的宕机也会产生问题。&lt;/p&gt;

&lt;p&gt;但这个升级又不得不进行，长痛不如短痛，趁集群内服务还不是太多的时候，得赶紧想个方案。&lt;/p&gt;

&lt;p&gt;最后，因为集群内服务还不多，而且都是无状态的，我们直接新建了一个临时集群，把当时的十几个服务在新集群跑了起来。&lt;/p&gt;

&lt;p&gt;然后把流量切到了临时集群后开始升级。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;kops-kubernetes-api-server-配置损坏&quot;&gt;kops Kubernetes API Server 配置损坏&lt;/h3&gt;

&lt;p&gt;可惜升级集群也不是一帆风顺，虽然在测试环境已经演练过了，但是线上竟然一直卡着不动。&lt;/p&gt;

&lt;p&gt;而我又做了个很傻的操作，我把 Master 节点重启了。然后就没有然后了…&lt;/p&gt;

&lt;p&gt;现在回想起来真想抽自己一个大嘴巴。&lt;/p&gt;

&lt;p&gt;不幸中的万幸，我按照 kops 迁移文档对 etcd 的磁盘做了镜像备份。但先要把原因找出来，登陆上 Master 节点查看各种日志，唯一有价值的就是提示 etcd 配置损坏的日志。但是为什么损坏？找了半天还是没找到。&lt;/p&gt;

&lt;p&gt;后来发现了一个迁移进度的日志，发现里面并没有什么错误，迁移也没结束。再结合我的重启操作联想一下，猜测应该是迁移并未结束就被我重启了，所以导致配置损坏。&lt;/p&gt;

&lt;p&gt;最后只能死马当作活马医了，停掉了 Master 节点，把 etcd 的磁盘从镜像中恢复，再重启 Master 节点。&lt;/p&gt;

&lt;p&gt;这次我一直盯着迁移进度，直到它完成。整个迁移过程花了将近半个小时。&lt;/p&gt;

&lt;p&gt;因为在测试环境这个过程只有几秒，线上几分钟不动，所以让我以为是卡住了。&lt;/p&gt;

&lt;p&gt;但说到底，我直接重启的操作是万万不可取的，以后再遇到类似的问题，第一步一定是去找原因，找到了原因再去重启。否则后果很严重。另外还有一个教训，做这种大的运维操作，记得备份，小心驶得万年船。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;kubernetes-api-server-高可用&quot;&gt;Kubernetes API Server 高可用&lt;/h3&gt;

&lt;p&gt;我们用 kops 算是很早的了，当时 kops 并没有 Master 节点高可用方案。Master 是单节点那么意味着 Kubernetes API Server 也是单节点。虽然 Calico 和 CoreDNS 都是强依赖 Kubernetes API Server，但是短暂的宕机并不会有严重的问题。例如 Master 节点升级，几分钟不会有严重的影响。&lt;/p&gt;

&lt;p&gt;但在 2019 年年中开始，我们集群会出现大量的 DNS 超时。当时的业务已经不少了，而且公司整个数据平台也是基于 Kubernetes 搭建的，所以整个集群 Kubernetes API Server 的压力是非常大的。&lt;/p&gt;

&lt;p&gt;最后研究后发现是 Kubernetes API Server 负载过高，导致 CoreDNS 访问 Kubernetes API Server 超时重启。最后引发了 DNS 超时。整个排查过程也不难，DNS 超时那么肯定先去看 CoreDNS 日志，然后就发现了原因。&lt;/p&gt;

&lt;p&gt;新版本的 kops 虽然提供了多 Master 的支持，但是却一直没有完善单节点到多节点的迁移教程。&lt;/p&gt;

&lt;p&gt;当时教程是有的，但是却没有故障恢复这个部分。经历过上次的升级问题后，没有故障恢复就很慌，完全不敢操作。&lt;/p&gt;

&lt;p&gt;官方在 2019 年 8 月才把故障恢复这部分文档补齐：&lt;a href=&quot;https://github.com/kubernetes/kops/commit/a27b0f4439a386887d680c79fbe2300ca7c1c9bb#diff-12ee8d2ec7d8967931a5d72ecc62dadf&quot;&gt;Added // restore // guide to single-to-multi-master.md&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在我们等待 kops 官方补齐这部分文档的时候，AWS 中国区的技术专员和我们一起交流了一下我们在 AWS 中使用 Kubernetes 的一些问题。他们向我们推荐了 Amazon EKS，而它和 kops 最大的区别就是：EKS 的 Master 节点是全托管的。Node 节点和 kops 一样是自己管理的。而且 EKS 的一些功能和 AWS 整合地更紧密，虽然这些功能 AWS 都开源做成了标准化 Kubernetes 插件了，但使用便捷性上，亲生的 EKS 还是要更胜一筹。&lt;/p&gt;

&lt;p&gt;其中 Master 节点全托管这点非常吸引我们，因为我们出过的问题和面临的问题全部是和 Master 节点相关的。而 AWS 可以保证 Master 节点的稳定可靠和无缝升级，那对我们的运维工作帮助非常大。&lt;/p&gt;

&lt;p&gt;我们公司没有运维，没有 DBA。所有相关工作都是我们自己做的，实在是没精力去研究这些了。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;调研-eks&quot;&gt;调研 EKS&lt;/h3&gt;

&lt;p&gt;EKS 那么好，那有什么问题吗？这个问题在和 AWS 技术专员交流的时候就问了，其中最大的一个问题就是 EKS 默认用的网络插件是 Amazon VPC CNI：&lt;a href=&quot;https://github.com/aws/amazon-vpc-cni-k8s&quot;&gt;amazon-vpc-cni-k8s&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;它可以直接给&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt;分配一个 VPC 内的 IP，就好像是 VPC 内的一台机器一样。这给业务调试带来了极大的便利。&lt;/p&gt;

&lt;p&gt;另外从性能角度也在各方面领先 Calico：&lt;a href=&quot;https://medium.com/@jwenz723/amazon-vpc-cni-vs-calico-cni-vs-weave-net-cni-on-eks-b0ad8102e849&quot;&gt;Amazon VPC CNI vs Calico CNI vs Weave Net CNI on EKS&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;但是单台 EC2 IP 总是有限制，目前最多 30 多个，我们看了下我们适合的机器配置和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt;运行情况，一般单机也不会超过 30 个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt;，所以这个缺点对我们来说问题不大。&lt;/p&gt;

&lt;p&gt;另外 EKS 的操作理念和 kops 有些不同。kops 是把线上资源和本地 yaml 配置做对比，然后生成对应的操作。&lt;/p&gt;

&lt;p&gt;而 EKS 利用了 &lt;a href=&quot;https://aws.amazon.com/cloudformation/&quot;&gt;Amazon Cloudformation&lt;/a&gt;，用它来管理资源。&lt;/p&gt;

&lt;p&gt;Cloudformation 最麻烦的一点就是，它的理念是一旦提交就不可变，所以 EKS 不能&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rolling-update&lt;/code&gt;一组机器。它只能新建一组机器再把老的那组机器销毁，这个过程略嫌麻烦，最后我们通过自己写了点脚本来解决，整体来说也不是什么大问题。&lt;/p&gt;

&lt;p&gt;另外 EKS 升级真的是无缝的？这个肯定也要自己试一下，建一个老版本集群集群，压测一下，然后升级。&lt;/p&gt;

&lt;p&gt;最后果然是无缝的，据说 EKS 内部 Master 节点魔改了一些东西，可以保证这块的高可用。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;迁移到-eks&quot;&gt;迁移到 EKS&lt;/h3&gt;

&lt;p&gt;托管 Master 的诱惑实在太大，调研结束后我们就准备迁移了。&lt;/p&gt;

&lt;p&gt;上次新建临时集群的时候，我们大部分服务都是无状态的，但这次，我们有状态的服务已经不少了。有些服务用了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PersistentVolumeClaim&lt;/code&gt;，所以你得把它们磁盘里的数据迁移过去。&lt;/p&gt;

&lt;p&gt;除此以外也并没有什么太大的难度，新集群建好后流量通过负载均衡器慢慢切过去就行了，最后线上整个迁移过程也就用了几天而已。&lt;/p&gt;

&lt;p&gt;目前我们已经在 EKS 中运作大半年了，整体非常稳定，没有出现过任何相关的故障。也经历过一次 Kubernetes 版本升级，整个过程是无缝的。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;aws-fargate&quot;&gt;AWS Fargate&lt;/h3&gt;

&lt;p&gt;最近 AWS 推出了 &lt;a href=&quot;https://docs.aws.amazon.com/eks/latest/userguide/fargate.html&quot;&gt;Fargate&lt;/a&gt;，可以理解为是全托管的 Kubernetes 集群。&lt;/p&gt;

&lt;p&gt;但是目前限制非常多，例如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DaemonSet&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StatefulSet&lt;/code&gt;等特殊的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt;都是不支持或者是不提倡使用的。&lt;/p&gt;

&lt;p&gt;目前我们这类有状态的应用还是挺多的，所以如果是单集群的话它明显不能满足我们的需求。未来等我们有了多集群方案，这种全托管的 Kubernetes 可以考虑搭配使用。&lt;/p&gt;
</description>
				<pubDate>Thu, 20 Feb 2020 00:00:00 +0000</pubDate>
				<link>/2020/02/migrate-kops-to-eks.html</link>
				<guid isPermaLink="true">/2020/02/migrate-kops-to-eks.html</guid>
			</item>
		
			<item>
				<title>Service Mesh 实践（零）：转型之路</title>
				<description>&lt;h3 id=&quot;原始社会&quot;&gt;原始社会&lt;/h3&gt;

&lt;p&gt;刚来创业公司的时候，被这简单粗暴的“架构”设计震惊了，准确的说，这里并没有什么设计。整个后端就一个单体程序，整体结构和大学里写的三层架构差不多，好吧，好歹还做了一些分层。设计模式就别想找到了，面向对象都很少见。&lt;/p&gt;

&lt;p&gt;作为初创员工加入后，发现其实这种代码在人少时还挺高效的。本地搞点配置写个脚本，几秒内就可以把新代码发布到线上。&lt;/p&gt;

&lt;p&gt;此时我们大致的架构是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020/02/architecture_1.png&quot; alt=&quot;architecture_1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但随着团队的扩张，2人、5人、10人，当 10 个人往同一个没有良好设计的项目里 commit 代码的时候，问题也慢慢地开始显现了。&lt;/p&gt;

&lt;p&gt;代码冲突，发布依赖，线上雪崩… 是时候开始微服务化了。&lt;/p&gt;

&lt;p&gt;2018年7月，我们的转型之路正式开始。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt; &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;本文主要是介绍了我们做 Service Mesh 的技术背景和实施路线和每个阶段遇到的问题。其中有一些问题值得拿出来单独讲讲，所以后面还会有一篇篇的详解。&lt;/p&gt;

  &lt;p&gt;文中类似这样的标注：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(1)&lt;/code&gt;，可以去文章最后找到对应文章，看到更多内容。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;大众点评的微服务实践与经验&quot;&gt;大众点评的微服务实践与经验&lt;/h3&gt;

&lt;p&gt;在我们开始的时候，正是 Service Mesh 开始流行的时候，对我们来说这是一个全新的概念，但是这和以前的微服务有什么区别呢？&lt;/p&gt;

&lt;p&gt;为了搞清楚这些问题，当然要参考一下老东家走过的那些路：&lt;a href=&quot;https://cloud.tencent.com/developer/article/1054856&quot;&gt;高可用性系统在大众点评的实践与经验&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;文中有几个关键的阶段：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;幼儿时期：2012年前，使命：满足业务要求，快速上线。&lt;/li&gt;
  &lt;li&gt;少年时期：垂直拆分（2012-2013），使命：研发效率 &amp;amp; 故障隔离。&lt;/li&gt;
  &lt;li&gt;青年时期：服务做小，不共享数据（2014-2015），使命：支撑业务快速发展，提供高效、高可用的技术能力。&lt;/li&gt;
  &lt;li&gt;成年时期：水平拆分（2015至今），使命：系统要能支撑大规模的促销活动，订单系统能支撑每秒几万的 QPS，每日上千万的订单量。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;同时，我也联系了一些点评正在做服务治理的同事，了解到他们虽然在调研 Service Mesh，但是并没有启动 Service Mesh 相关的改造。美团的 OCTO 路线图中有准备在 2.0 中把 Agent 模式改造成 Proxy 模式，和 Service Mesh 里的 Sidecar 其实已经很接近了。但现在依然还是 Agent 模式，流量不经过 Agent。&lt;/p&gt;

&lt;p&gt;为什么他们不做 Service Mesh 转型？&lt;/p&gt;

&lt;p&gt;我们应该先做微服务改造然后再做 Service Mesh 还是直接上 Service Mesh？&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;举步维艰的微服务化&quot;&gt;举步维艰的微服务化&lt;/h3&gt;

&lt;p&gt;一开始因为更熟悉 Java 和大众点评那套架构设计，那自然就会优先选择 Java 生态链下的各种产品，包括大众点评，蚂蚁金服，携程还有 Spring Cloud 全家桶等。&lt;/p&gt;

&lt;p&gt;但在我构思从哪开始，一步步怎么走的时候，我快哭了。虽然 Java 生态链下开源产品很多，但不是一整套的解决方案。跨语言，RPC，服务注册与发现，监控，日志，分布式追踪，熔断，重试… 每一个问题拿出来都要做很久，不仅中间件开发成本大，所有的中间件也都要侵入代码，开发人员的成本也非常大。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;一颗银弹&quot;&gt;一颗银弹&lt;/h3&gt;

&lt;p&gt;正当我苦恼时，看到 Istio 1.0 发布了，Service Mesh 这个概念再一次出现在我们的面前。Istio 中的 Sidecar 模式也一下子把我们吸引过去了。&lt;/p&gt;

&lt;p&gt;Service Mesh 的详细介绍可以看这篇文章：&lt;a href=&quot;https://skyao.io/talk/201710-service-mesh-next-generation-microservice/&quot;&gt;Service Mesh：下一代微服务&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;看起来它好像解决了我们大部分的问题：跨语言，监控，分布式追踪，熔断，重试…&lt;/p&gt;

&lt;p&gt;我们也突然明白为什么大公司很难做 Service Mesh 转型了，因为他们已经有了很多成熟的中间件来解决这些问题。在没有大问题前推倒重来是不现实的。国内走得最快的应该是蚂蚁金服了，基于 Istio 改造扩展了 SOFAMesh。&lt;/p&gt;

&lt;p&gt;另一个问题也慢慢变得清晰了，我们还需要先做微服务再做 Service Mesh 吗？很明显答案是否定的。&lt;/p&gt;

&lt;p&gt;Service Mesh 不是一个慢慢演进的产物，而是一个颠覆的产物。对于我们这种处于原始社会的架构设计来说，直接开始比慢慢演进更容易。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;技术选型&quot;&gt;技术选型&lt;/h3&gt;

&lt;p&gt;整个技术选型的过程没有很曲折，因为可选的方案不多。&lt;/p&gt;

&lt;p&gt;想要上 Service Mesh 那容器编排基本是逃不掉的，而 Kubernetes 基本就是容器编排的唯一标准了。&lt;/p&gt;

&lt;p&gt;而 &lt;a href=&quot;http://istio.io/&quot;&gt;Istio&lt;/a&gt; 也没有太多竞争对手，当时没有，到现在基本也没有。&lt;/p&gt;

&lt;p&gt;AWS 后来出了一个 &lt;a href=&quot;https://aws.amazon.com/app-mesh/&quot;&gt;App Mesh&lt;/a&gt;， Sidecar 也是和 Istio 一样用的 &lt;a href=&quot;https://www.envoyproxy.io/&quot;&gt;Envoy&lt;/a&gt;，所以本质上并没有太大的区别。最大的优势就是控制平面可以不需要自己维护的，AWS 帮你托管了，这个算是一个最大的优势了。&lt;/p&gt;

&lt;p&gt;其实，就算未来 Kubernetes 和 Istio 出现了继承者，Service Mesh 下开发的业务也是低侵入，容器化的。后续再迁移到别的技术栈并不是一个太复杂的过程。再加上 Kubernetes 和 Istio 背靠 Google，也给了我们更多的信心。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;集群搭建&quot;&gt;集群搭建&lt;/h3&gt;

&lt;p&gt;在 Kubernetes 集群的搭建上，也没有太多选择。一个是官方出的 kubeadm，便于你搭建集群和后续的集群维护。而另一个是官方出的 kops，两者最大的区别是 kubeadm 主要是针对裸机操作的，而 kops 是对云厂商操作的。&lt;/p&gt;

&lt;p&gt;举个例如，如果你要搭建一个集群，用 kubeadm 的话集群你总要自己准备好吧。而 kops 不用，你选择好你的云厂商，并配置好对应的权限后，它可以做到一条龙服务，包括建机器，建集群，磁盘，负载均衡等都可以帮你一条龙搞定。&lt;/p&gt;

&lt;p&gt;你要做的只是维护一份 yaml 文件来管理你的集群配置而已。我们的服务在 AWS 上，kops 会帮你装上所有 AWS 相关的插件，例如 &lt;a href=&quot;https://aws.amazon.com/ebs/&quot;&gt;Amazon EBS&lt;/a&gt; 存储插件，你在集群内直接创建&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PersistentVolumeClaim&lt;/code&gt;后插件就会自动帮你在 Amazon EBS 里创建一块磁盘了。&lt;/p&gt;

&lt;p&gt;kops 虽然是一条龙服务，但是它的使用方式非常可控。不像别的一些傻瓜式的软件，它做了什么你都不知道。&lt;/p&gt;

&lt;p&gt;这里的可控主要体现在无论你是创建还是修改集群，修改完 yaml 配置提交变更前，它都会像&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git diff&lt;/code&gt;一样告诉你哪些资源被改了，哪些资源被删了。&lt;/p&gt;

&lt;p&gt;除此以外，所有建出来的资源，例如 EC2，你都可以直接登陆上去，这个在排查问题的时候帮助也是很大的。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;istio-的配置&quot;&gt;Istio 的配置&lt;/h3&gt;

&lt;p&gt;Istio 跑起来不难，配置好不容易。&lt;/p&gt;

&lt;p&gt;首先是 Istio 1.0 刚发布，业内根本没有参考。所以通读 Istio 文档是必须的。还好 Istio 文档整体写的非常不错，也有丰富的例子。自己根据它的例子上手做一遍，大致怎么玩就知道了。&lt;/p&gt;

&lt;p&gt;但是初期版本的 Istio 文档还是略显简陋，很多细节并没有在文档中体现。&lt;/p&gt;

&lt;p&gt;例如用作流量控制的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DestinationRule&lt;/code&gt;里的很多参数就找不到细节。Istio 本质上是下发配置给 Envoy，所以这块最后是根据 Envoy 的配置再去翻查 Envoy 的文档来理解的。&lt;/p&gt;

&lt;p&gt;还有比如 Istio 中怎么把特定的一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Deployment&lt;/code&gt;禁用 Sidecar 呢？最早的文档中也是没有的，但是在底层却发现了相关的参数，最终翻查 Istio 源码的过程中终于找到了相关配置。&lt;/p&gt;

&lt;p&gt;随着 Istio 新版本的发布，这些初期遇到的问题其实他们都可以很好的解决了。现在开始用的人并不一定会遇到这些问题。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;可行性验证&quot;&gt;可行性验证&lt;/h3&gt;

&lt;p&gt;到了这步，各种 Demo 都跑得差不多了，但不去真刀实枪的干一下，很多问题是不会暴露出来的。不去实战验证一下的话，也是不敢大规模推广的。&lt;/p&gt;

&lt;p&gt;这里我主要想解决这些问题：&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h5 id=&quot;哪些业务更适合用来做实验&quot;&gt;哪些业务更适合用来做实验？&lt;/h5&gt;

&lt;p&gt;一种拆法是垂直拆分，如果原来的单体程序中业务都比较独立，那这样是可行的。但事实并不是这样，虽然我们各个业务都是独立的，但是中间公用的业务还不少。例如一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;block&lt;/code&gt;功能，用户可以把别人&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;block&lt;/code&gt;，而&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;block&lt;/code&gt;之后在上层很多代码中需要做检查。&lt;/p&gt;

&lt;p&gt;所以，水平拆分开起来是一个更可行的方案，而且也只能从底层开始，把依赖最少的模块独立出来。例如上面提到的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;block&lt;/code&gt;功能，它内部只依赖了数据库，并不会再涉及到别的业务了。&lt;/p&gt;

&lt;p&gt;这个功能的调用量不小，功能简单，就算完全挂了也不会有严重的影响，看似是一个非常适合的小白鼠。于是我们第一个 Service Mesh 项目&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;block-sercice&lt;/code&gt;就诞生了。&lt;/p&gt;

&lt;p&gt;如果第一个项目验证通过后，未来怎么继续迁移呢？我觉得可以继续按照这个思路去做迁移。把整个项目内部模块想像成一个树的话，从叶子节点慢慢的开始迁移，最终把整棵树挪过去。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h5 id=&quot;新老架构如何互通&quot;&gt;新老架构如何互通？&lt;/h5&gt;

&lt;p&gt;这个问题不难解决，老的单体程序虽然在 Kubernetes 集群外，但是完全可以通过 HTTP 访问。虽然这不是性能最佳的方案，但如果只是迁移过程中的方案的话，并不是不可接受。因为这个阶段小步快跑，灵活掉头更重要。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h5 id=&quot;独立成服务后会出现哪些问题&quot;&gt;独立成服务后会出现哪些问题？&lt;/h5&gt;

&lt;p&gt;这个问题在开发和上线运行的过程中出现了很多，最大的问题是很多标准和基础设施的缺失。虽说 Service Mesh 是一颗银弹，但这颗银弹不能解决所有微服务化下需要解决的问题，还是有很多东西需要亲自操刀的。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h5 id=&quot;独立成服务后性能有多大的差别&quot;&gt;独立成服务后性能有多大的差别？&lt;/h5&gt;

&lt;p&gt;不用测就知道这块肯定是有非常大的性能差异的。代码直接调用改成 RPC，那单纯的性能必定是成倍的下降。这是不可避免的，要解决它，我觉得依然从单纯性能角度去解决是没有出路的，网络请求的瓶颈摆在那，这是无法逾越的。&lt;/p&gt;

&lt;p&gt;要解决它，只盯着一个请求看不行的，应该从更高的角度看整个调用链，然后想办法去做优化。&lt;/p&gt;

&lt;p&gt;后面也会有专门的文章介绍我在这块的思考。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(9)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h5 id=&quot;kubernetes-和-istio-的组合是否稳定&quot;&gt;Kubernetes 和 Istio 的组合是否稳定？&lt;/h5&gt;

&lt;p&gt;这个问题在第一个项目验证的时候，并没有体现，但在后续越来越多项目迁入的时候，都发现了一些问题。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(1)&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(2)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h5 id=&quot;验证的过程中如何做故障转移一键或自动切换到老代码&quot;&gt;验证的过程中如何做故障转移、一键或自动切换到老代码？&lt;/h5&gt;

&lt;p&gt;这个问题也不难，我在我们老的单体程序里面实现了一套限流，熔断，故障转移的机制。如果 Kubernetes 集群内的服务挂了，直接访问老代码，这样就完全不会影响线上业务了。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;最后，这个项目上线后，后面要做什么我们也越来越清晰了。在验证它可靠性的同时，我们也开始一步步解决上面遇到的问题了。&lt;/p&gt;

&lt;p&gt;目前和以前最大的区别就是，以前 block 相关的业务是以前的单体程序直接访问数据库的，现在是先访问 Kubernetes 集群内的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;block-service&lt;/code&gt;，由这个服务访问相关数据库。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020/02/architecture_2.png&quot; alt=&quot;architecture_2&quot; /&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;基础设施基本可用&quot;&gt;基础设施基本可用&lt;/h3&gt;

&lt;p&gt;之前提到各种标准和基础设施的缺失阻碍了我们前进的步伐，不把这个解决大家就没办法继续了。总不能让大家自己手工 build 镜像，自己上传，再自己手写 yaml 吧。&lt;/p&gt;

&lt;p&gt;先不管好不好用，第一个短期目标起码是可用，从整个项目的开发运作来看，主要需要这些东西：&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h5 id=&quot;rpc-协议&quot;&gt;RPC 协议&lt;/h5&gt;

&lt;p&gt;对于 Service Mesh 架构来说，服务发现，注册中心，健康检查这些问题在 Kubernetes 中根本就不是问题了，因为它本身已经提供了很好的支持；然后 Istio 又帮你解决了流量控制这块的需求。&lt;/p&gt;

&lt;p&gt;但是最终协议还是需要自己选择一下的，是直接用 HTTP 还是 gRPC？Istio 目前也只支持这两种协议。从性能角度来看，gRPC 肯定是更好的选择，gRPC 基于 HTTP/2，所以拥有 HTTP/2 的各种特性，再加上 gRPC 在编码解码上的特性，速度比 HTTP 要快非常多。&lt;/p&gt;

&lt;p&gt;因为 gRPC 基于 HTTP/2，其实两者并不冲突，很多 gRPC 的概念都是和 HTTP 一一对应的。例如 gRPC 里的 Metadata 本质上就是 HTTP Header。同一个微服务完全可以同时提供两种协议，而且业务代码完全是一样的。只要在外层做一层适配器，写一下路由，用一些工具类把 gRPC Metadata 和 HTTP Header 提取一下变成一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt;，后面业务只管处理业务就行了，并不需要做额外的工作。&lt;/p&gt;

&lt;p&gt;另外这个项目 &lt;a href=&quot;https://github.com/grpc-ecosystem/grpc-gateway&quot;&gt;grpc-gateway&lt;/a&gt;，可以直接把 gRPC 封装成一个 HTTP 服务，额外多一次网络请求，具体怎么实现根据你的场景来选择。&lt;/p&gt;

&lt;p&gt;虽然 gRPC 在语言的支持上已经非常丰富了，但我们一开始还要支持老的单体程序，老项目是 Python，用 gRPC 还是遇到了不少问题的。所以早期阶段我们的服务先只提供 HTTP 的接口，后续的业务慢慢加上了 HTTP 和 gRPC 双协议支持。长期的发展应该是 gRPC 为主，按需提供 HTTP 接口。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h5 id=&quot;项目打包标准&quot;&gt;项目打包标准&lt;/h5&gt;

&lt;p&gt;Kubernetes 做容器编排，那么容器化是必须的了。但是镜像并不能直接在 Kubernetes 中欢快地跑起来，除了镜像，你还缺了很多 Kubernetes 资源配置。&lt;/p&gt;

&lt;p&gt;理论上，Kubernetes 资源配置大部分内容是相似的，对于一个微服务来说总是需要这些东西：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Service&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HorizontalPodAutoscaler&lt;/code&gt;等，但因为我们公司技术栈比较分散，暂时还很难做一些通用的模版。所以前期我们会把 Kubernetes 资源配置以 &lt;a href=&quot;https://helm.sh/&quot;&gt;Helm Chart&lt;/a&gt; 的形式放在代码仓库中，CI / CD 不仅仅会 build 镜像，还会打包 Helm Chart。&lt;/p&gt;

&lt;p&gt;而后面同质化的项目越来越多后，我觉得可以提供一种零配置的选择，让简单的业务可以不用自己去维护 Helm Chart 了。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h5 id=&quot;ci--cd&quot;&gt;CI / CD&lt;/h5&gt;

&lt;p&gt;我们调研了不少理念和工具。在前期通过 Jenkins Pipeline 实现了一个可用版，但还缺失了很多功能，只能说基本可用。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(7)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h5 id=&quot;监控报警&quot;&gt;监控，报警&lt;/h5&gt;

&lt;p&gt;&lt;a href=&quot;https://prometheus.io/&quot;&gt;Prometheus&lt;/a&gt; 是 Cloud Native 的顶级项目，对 Kubernetes 的支持当然不在话下。Prometheus + Grafana 也是这里最佳的选择。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h5 id=&quot;分布式追踪&quot;&gt;分布式追踪&lt;/h5&gt;

&lt;p&gt;Istio 的蓝图中，可观测性是一个很大的亮点。所以前期我们分布式追踪也用了 Istio 内置 Jeager 的解决方案。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(2)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h5 id=&quot;日志搜集&quot;&gt;日志搜集&lt;/h5&gt;

&lt;p&gt;依然是 Cloud Native 中的开源项目，&lt;a href=&quot;https://fluentbit.io/&quot;&gt;Fluent Bit&lt;/a&gt; 是针对 Kubernetes 用 C 语言重现的 Fluentd。它针对 Kubernetes 做了很多优化。&lt;/p&gt;

&lt;p&gt;再配合 Elasticsearch，可以基本满足我们对日志搜集的需求。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h5 id=&quot;完善文档&quot;&gt;完善文档&lt;/h5&gt;

&lt;p&gt;整个 Service Mesh 推进的过程中，大量的新概念出现，特别是前期很多基础设施不完善的时候，开发更需要去学习更多技术细节。在整个基础设施从零到可用的过程中，我们也把所有的东西怎么搭建，怎么配置，怎么使用全部写成了内部文档。为团队成员提供了便利，也节约了自己的时间。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;这个阶段经历了几个月的时间，同时，最早迁移的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;block-service&lt;/code&gt;也稳定运行半年左右了，准备就绪！&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;新项目越来越多老项目越迁越多&quot;&gt;新项目越来越多，老项目越迁越多&lt;/h3&gt;

&lt;p&gt;验证完可行性，基础设施基本可用后，整个转型进度走上了快车道。&lt;/p&gt;

&lt;p&gt;2019 年年初，正好有个大项目需要开发很多新的独立的模块；同时，有很多老项目用 MySQL 已经无法支撑，需要重写并采用别的数据库方案。这两个场景正好和技术转型非常对口。&lt;/p&gt;

&lt;p&gt;在2019年年底的时候，我看了看 Jenkins 上的项目，竟然已经到了 100+，线上集群 Pod 数量也达到了 1000+。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;基础设施改进&quot;&gt;基础设施改进&lt;/h3&gt;

&lt;p&gt;在 2019 年 Service Mesh 快速推进的时候，所有人对各种基础设施的要求也不再仅仅满足于可用了，一个个需求冒了出来。&lt;/p&gt;

&lt;p&gt;但实战中的需求会比脑补出来的需求靠谱很多，很多时候不怕没需求，就怕需求没想明白。&lt;/p&gt;

&lt;p&gt;整个 2019 年至今，我们发现并解决了这些问题：&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h5 id=&quot;kubernetes-master-节点性能问题&quot;&gt;Kubernetes Master 节点性能问题&lt;/h5&gt;

&lt;p&gt;在使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kops&lt;/code&gt;的过程中我们出现过2个大问题，每次都造成了分钟级别的线上宕机，最后我们迁移到了 &lt;a href=&quot;https://aws.amazon.com/eks/&quot;&gt;Amazon EKS&lt;/a&gt;。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(1)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h5 id=&quot;istio-性能问题&quot;&gt;Istio 性能问题&lt;/h5&gt;

&lt;p&gt;Istio 的 Mixer 模块对性能的影响不小，而且整体来说 Mixer 并不好用。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(2)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h5 id=&quot;数据库中间件&quot;&gt;数据库中间件&lt;/h5&gt;

&lt;p&gt;为什么数据库需要中间件而不是直接访问呢？有人可能会想到会不会是因为微服务化后服务太多，连接数太多？这的确是一个问题，但在良好的设计下，一个业务应该是一套独立的数据库，不应该出现那种被大量业务直接访问的数据库。如果有，那么这样的数据库应该被做成一个微服务。&lt;/p&gt;

&lt;p&gt;我们做这个主要是想解决多语言读写分离的需求，因为我们内部语言多，很难为所有语言找到好用的读写分离中间件，所以我们还是去调研了一些 Proxy 模式的数据库中间件，并在线上采用了。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(3)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h5 id=&quot;api-gateway&quot;&gt;API Gateway&lt;/h5&gt;

&lt;p&gt;自研 API Gateway 是迟早的事情，因为 API Gateway 和自身业务关系紧密。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(4)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h5 id=&quot;优雅启动和优雅关闭&quot;&gt;优雅启动和优雅关闭&lt;/h5&gt;

&lt;p&gt;Java 程序启动太慢，Golang 程序启动太快… 如何做到优雅启动和优雅关闭？&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(5)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h5 id=&quot;horizontalpodautoscaler-支持自定义-metrics&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HorizontalPodAutoscaler&lt;/code&gt; 支持自定义 Metrics&lt;/h5&gt;

&lt;p&gt;主要靠开源项目 &lt;a href=&quot;https://github.com/DirectXMan12/k8s-prometheus-adapter&quot;&gt;k8s-prometheus-adapte&lt;/a&gt; 解决，整体难度不大。&lt;/p&gt;

&lt;p&gt;但后面可以讲讲为什么需要让&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HorizontalPodAutoscaler&lt;/code&gt; 支持自定义 Metrics。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(10)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h5 id=&quot;aws-账号与-kubernetes-账号身份认证打通&quot;&gt;AWS 账号与 Kubernetes 账号身份认证打通&lt;/h5&gt;

&lt;p&gt;同样是靠开源项目 &lt;a href=&quot;https://github.com/kubernetes-sigs/aws-iam-authenticator&quot;&gt;aws-iam-authenticator&lt;/a&gt;。但是它只能解决认证问题，不能解决授权问题。我们的解决方案是通过脚本把 AWS User, Group 和 Kubernetes RBAC User, Group 做映射，来解决 Kubernetes 内部的权限管理问题。因为我们团队规模还不大，暂时没有产品化，只是一些简单的脚本。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h5 id=&quot;i18n&quot;&gt;I18N&lt;/h5&gt;

&lt;p&gt;我们是一个面向全球的 App，所以所有也许都要做翻译工作。之前单一程序通过一些脚本就可以做到翻译文件的管理，但现在业务拆开后，不可能每个项目中都把这部分代码重新实现一遍。做成中间件不现实，业务自己调对应的服务也不现实，如何配合 API Gateway 来解决这个问题呢？&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(6)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h5 id=&quot;ci--cd-1&quot;&gt;CI / CD&lt;/h5&gt;

&lt;p&gt;CI / CD 再次出现，原因很明显，第一版的 CI / CD 不好用，后续我们对它进行了改造。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(7)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h5 id=&quot;分布式上下文&quot;&gt;分布式上下文&lt;/h5&gt;

&lt;p&gt;一般 RPC 服务都会自动传播上下文，这样可以在调用链上游下游之间共享一些数据。但 Service Mesh 的重要一点是跨语言，RPC 协议也只是普通的 HTTP 或 gRPC，它们并没有相关协议。所以这块只能我们自己研发了。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(8)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;最后的单体程序改造&quot;&gt;最后的单体程序改造&lt;/h3&gt;

&lt;p&gt;当最老的单体程序业务能拆的都拆了以后，它依然是那么庞大。随着公司发展，总有那么一堆代码，复杂，看不懂，但是又不能去掉它们。&lt;/p&gt;

&lt;p&gt;花大精力去把这部分代码重构不现实，在业务变动不大的情况下，这部分代码完全可以继续运作。&lt;/p&gt;

&lt;p&gt;但现在这个单体程序是我们所有流量的入口，很多迁移成独立服务的流量还是要经过它，它要处理身份认证等功能。&lt;/p&gt;

&lt;p&gt;之前提到我们已经有自研的 API Gateway 了，那是不是可以把身份认证这样的功能迁移到 API Gateway 中，把已经改造完的项目直接通过 API Gateway 访问？把最老的单体程序中所有的通用功能迁移出来，只留下业务代码。最后再把它整体迁移到 Kubernetes 中，把它当成一个老业务的大杂烩服务。&lt;/p&gt;

&lt;p&gt;这个想法其实由来已久，但一直没动工的原因就是 API Gateway 还没支持好所有的通用功能；另外 CI / CD 一开始也不成熟，这个项目很大，没有金丝雀发布，没有回滚功能的话不敢迁移。&lt;/p&gt;

&lt;p&gt;最后，就在 2020 年初，把这两个障碍扫除后，我们也在近期完成了单体程序整体的迁移。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020/02/architecture_3.png&quot; alt=&quot;architecture_3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;和上面的图对比一下，可以看到如下一些变化：&lt;/p&gt;

&lt;p&gt;以前直接在 EC2 里跑的单体程序没有了，被改造成了一个 Kubernetes 里的服务。很多业务也都被拆成了独立的服务。&lt;/p&gt;

&lt;p&gt;Kubernetes Ingress 从 Istio Ingress 换成了自研的 API Gateway。以前单体程序里的通用逻辑都在这里重新实现了一遍。&lt;/p&gt;

&lt;p&gt;最后，存储也变得多样性了，业务变大以后 MySQL 不能满足所有需求了。&lt;/p&gt;

&lt;p&gt;至此，我们的 Service Mesh 转型之路算是告一段落了！&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;更多内容&quot;&gt;更多内容&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;以下内容如果没有链接代表还未完成。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;/2020/02/migrate-kops-to-eks.html&quot;&gt;Service Mesh 实践（一）：从 kops 到 EKS&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2020/02/replace-istio-mixer.html&quot;&gt;Service Mesh 实践（二）：Istio Mixer 模块的性能问题与替代方案&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2020/02/database-middleware.html&quot;&gt;Service Mesh 实践（三）：数据库中间件&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2020/02/api-gateway.html&quot;&gt;Service Mesh 实践（四）：从开源 Ingress 到自研 API Gateway&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2020/02/graceful-start-and-shutdown.html&quot;&gt;Service Mesh 实践（五）：优雅启动和优雅关闭&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2020/03/i18n-language.html&quot;&gt;Service Mesh 实践（六）：I18N Language&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2020/03/ci-cd.html&quot;&gt;Service Mesh 实践（七）：CI / CD 的变迁&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2020/03/distributed-context.html&quot;&gt;Service Mesh 实践（八）：分布式上下文&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Service Mesh 实践（九）：为什么 Golang 更适合 Service Mesh&lt;/li&gt;
  &lt;li&gt;Service Mesh 实践（十）：HorizontalPodAutoscaler 支持自定义 Metrics&lt;/li&gt;
  &lt;li&gt;Service Mesh 实践（十一）：健康检查最佳实践&lt;/li&gt;
&lt;/ol&gt;
</description>
				<pubDate>Sun, 16 Feb 2020 00:00:00 +0000</pubDate>
				<link>/2020/02/service-mesh-in-action.html</link>
				<guid isPermaLink="true">/2020/02/service-mesh-in-action.html</guid>
			</item>
		
			<item>
				<title>罗技 G29 与 Playseat 挑战者评测</title>
				<description>&lt;h3 id=&quot;想要一套不占地方的赛车座椅&quot;&gt;想要一套不占地方的赛车座椅&lt;/h3&gt;

&lt;p&gt;很早之前，在咸鱼买了一套罗技 G29 赛车游戏方向盘，全新的一套2500以上，用1600的价格买到一套二手的，算是捡了个便宜。&lt;/p&gt;

&lt;p&gt;卖家顺便送了一套简易的支架，放在自己的椅子前就可以玩。但是那坐姿，根本不是开车啊，简直是一种煎熬。&lt;/p&gt;

&lt;p&gt;于是在网上寻觅赛车座椅，价格倒不是问题，可以接受，但这个体积实在是…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2017/05/ps4_9.png&quot; alt=&quot;Playseat&quot; /&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt; &lt;/p&gt;

&lt;iframe frameborder=&quot;0&quot; width=&quot;640&quot; height=&quot;498&quot; src=&quot;https://v.qq.com/iframe/player.html?vid=q0505suumo3&amp;amp;tiny=0&amp;amp;auto=0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;我也不可能天天玩，不玩的时候放哪呢？这东西差不多有一个沙发大小，而且很重。&lt;/p&gt;

&lt;p&gt;直到某一天，我看到了它！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2017/05/ps4_10.png&quot; alt=&quot;Playseat&quot; /&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;正在寻觅购买渠道的时候，正好发现它的国行版在京东首发了，因为东西还是挺大的，海淘算上运费后远超国行的价格。所以就毫不犹豫地入手了！&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;评测&quot;&gt;评测&lt;/h3&gt;

&lt;p&gt;买 Playseat 挑战者之前，主要担心这几个问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;和罗技 G29 搭配使用效果如何？&lt;/li&gt;
  &lt;li&gt;椅子看起来很单薄，会不会不稳，会不会不结实？&lt;/li&gt;
  &lt;li&gt;虽然折叠起来体积很小，但是收纳是否方便？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;还好京东首发，不满意退货呗。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;g29-搭配照&quot;&gt;G29 搭配照&lt;/h4&gt;

&lt;p&gt;G29 的方向盘、排档杆、踏板都很完美地装上了！第一个疑问解除。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2017/05/ps4_1.jpg&quot; alt=&quot;G29&quot; /&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;走线也非常方便，可以仔细观察一下，我用了很多扎带来固定各种线。最后露出来的就两根，一根接电源，一根接 PS4。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2017/05/ps4_2.jpg&quot; alt=&quot;G29&quot; /&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;罗技-g29-手感脚感&quot;&gt;罗技 G29 手感脚感&lt;/h4&gt;

&lt;p&gt;顺便说说 G29，G29 是“专业”设备里最便宜的了，算是入门装备。&lt;/p&gt;

&lt;p&gt;首先它设备齐全，与 PS4 兼容性好。&lt;/p&gt;

&lt;p&gt;特别是玩 Project CARS（赛车计划）的时候，设置成手动模式并关闭自动离合器的时候，你不踩离合是无法换挡的。&lt;/p&gt;

&lt;p&gt;Driving Club（驾驶俱乐部）支持性稍差，离合器好像是不支持的。&lt;/p&gt;

&lt;p&gt;但两款游戏取向本来就不同，前者是专业取向，后者是娱乐取向。&lt;/p&gt;

&lt;p&gt;玩 Project CARS 真的很累，热车，调节，排位赛，一个个环节都和真的一样，悬挂之类的各种参数全部可以调节。&lt;/p&gt;

&lt;p&gt;Driving Club 就没这么啰嗦了，上来就直接跑。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;先说脚感吧，油门线性，和真车脚感类似。刹车偏硬，这个也合情合理，毕竟赛车都是没刹车助力的。所以刹车要狠狠地踩，力道很足！&lt;/p&gt;

&lt;p&gt;如果非要挑毛病的话就是缺少一些机械感，可能是因为没有路感所以让人不习惯吧。像真车踩刹车的时候，特别是急刹的时候，可以明显感觉到震动。如果踏板也有震动反馈就好了。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;接下来先说排档杆，外壳质感一般，塑料感比较强，好吧，本身就是塑料的。但不影响换挡手感，开起来感觉还行。平时用它的时候基本不会挂错档，所以手感还行。&lt;/p&gt;

&lt;p&gt;开手动的时候也可以用换挡拨片。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;最后来说说方向盘，这也是 G29 最大的问题，方向盘内部是齿轮结构的，所以虚位有点大。小幅度转动就是轻飘飘的感觉。但这毕竟是入门装备，没必要强求。&lt;/p&gt;

&lt;p&gt;有钱的都去买 Thrustmaster 的方向盘了，据说它是皮带的，转向手感会好很多。其实海淘一套 Thrustmaster 并不贵，看到亚马逊海外淘上原价2500，运费800（Prime 会员免运费），税600左右。有 Prime 会员的话3000多就拿下了。&lt;/p&gt;

&lt;p&gt;G29 方向盘除了虚位问题比较大外，震动反馈和力反馈还不错。特别是力反馈，力道非常足，足到什么地步？开久了我手臂酸疼！不得不在设置里把力反馈调小。&lt;/p&gt;

&lt;p&gt;同样是因为齿轮结构的原因，力反馈会有死角，产生的原因和虚位产生的原因应该是一样的，手感没那么细腻。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;playseat-挑战者坐感&quot;&gt;Playseat 挑战者坐感&lt;/h4&gt;

&lt;p&gt;第一次把 Playseat 挑战者装好坐下去的时候，就一个感觉！舒服！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2017/05/ps4_11.jpg&quot; alt=&quot;Playseat&quot; /&gt;&lt;/p&gt;

&lt;p&gt;坐姿没有那么夸张，和真车类似，但是贴合性非常好。我正常开车1-2小时会腰酸，有腰拖调节也没用，毕竟是坐着的。主要受力的地方还是屁股和腰。&lt;/p&gt;

&lt;p&gt;但在这个座椅上，就是介于坐着和半躺之间的。背部和肩部都有支撑，所以长时间玩也不会不舒服。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;正好说说第二点担心。整张椅子看起来单薄，钢管很细，椅面是用大面积魔术贴固定的。没坐上去的时候是摇摇晃晃的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2017/05/ps4_3.jpg&quot; alt=&quot;Playseat&quot; /&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2017/05/ps4_4.jpg&quot; alt=&quot;Playseat&quot; /&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;通过调节底部和扶手的魔术贴，可以切换椅子的角度。&lt;/p&gt;

&lt;p&gt;然后，一坐上去，反而就不摇晃了，人的体重正好压住了椅子。&lt;/p&gt;

&lt;p&gt;如果要挑毛病的话，最大的问题就是不能随时调节坐姿了，还好这个就我一个人玩，不需要经常挑。而且这样的坐姿兼容性比较好，老少兼宜。所以也不算是个大问题。&lt;/p&gt;

&lt;p&gt;脚底的踏板不能调节角度，但是可以调节距离，我的腿够长了，也可以调到舒服的位置。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;整体收纳&quot;&gt;整体收纳&lt;/h4&gt;

&lt;p&gt;最后是最关心的收纳部分：&lt;/p&gt;

&lt;p&gt;第一步先把电源线和 USB 先放到椅面。然后把方向盘下面的一个固定旋钮松开，方向盘会往下垂。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2017/05/ps4_5.jpg&quot; alt=&quot;Playseat&quot; /&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;第二部把椅子合起来，有专用的魔术贴可以可以固定。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2017/05/ps4_6.jpg&quot; alt=&quot;Playseat&quot; /&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;接下来把踏板收到最短的位置，然后抬起来，同样会有一个魔术贴可以固定。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2017/05/ps4_7.jpg&quot; alt=&quot;Playseat&quot; /&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;最后是收纳起来的效果，这体积控制得已经非常不错了！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2017/05/ps4_8.jpg&quot; alt=&quot;Playseat&quot; /&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;这里最让我满意的就是，收纳座椅的时候并不需要拆下方向盘，而已整体收纳。&lt;/p&gt;

&lt;p&gt;最多2分钟就搞定了，最后抬到储物的地方就行了。&lt;/p&gt;

&lt;p&gt;重量还行，一个男生抬起来没问题，但一个女生可能有点吃力。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;模拟终究是模拟&quot;&gt;模拟终究是模拟&lt;/h3&gt;

&lt;p&gt;驾驶还是开真的爽，虽然为了安全速度开不快，但过弯时的心脏跳动在游戏里是模拟不出来的。&lt;/p&gt;

&lt;p&gt;推荐个上海附近的山路好去处：浙江 S205 省道。沿路有很多旅游景点，路修得很好很平整，人也不多，非常适合体验山路驾驶的乐趣。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2017/05/s205.png&quot; alt=&quot;S205&quot; /&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;最后上一段视频：&lt;/p&gt;

&lt;iframe frameborder=&quot;0&quot; width=&quot;640&quot; height=&quot;498&quot; src=&quot;https://v.qq.com/iframe/player.html?vid=q0505k2jbyb&amp;amp;tiny=0&amp;amp;auto=0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;当然也要提醒大家，生命第一，安全第一，量力而行，准守交规。&lt;/p&gt;
</description>
				<pubDate>Sat, 20 May 2017 00:00:00 +0000</pubDate>
				<link>/2017/05/g29-and-playseat.html</link>
				<guid isPermaLink="true">/2017/05/g29-and-playseat.html</guid>
			</item>
		
	</channel>
</rss>
